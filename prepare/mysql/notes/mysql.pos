{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"1daebf3f4599","children":[{"parent":"5d3eb4bc4bc7","children":[{"parent":"5e109e24333d","note":"白话说就是为了满足数据的高效查找而设计的一种数据结构","children":[],"id":"23d733df2cbc","title":"定义"},{"parent":"5e109e24333d","children":[{"parent":"b5451044d06c","children":[{"parent":"f8a6f41949fc","children":[{"parent":"48b149f5cd32","note":"索引项的排序和对应数据的排序一致","children":[],"id":"19eaa899f14a","title":"聚集索引"},{"parent":"48b149f5cd32","note":"索引项的排序和对应的数据排序不一致","children":[],"id":"1ad79c97d9bc","title":"非聚集索引"}],"id":"48b149f5cd32","title":"维度1"},{"parent":"f8a6f41949fc","children":[{"parent":"a9fa6f746c42","note":"对主键建立的索引叫做主索引","children":[],"id":"8283c80c83a4","title":"主索引"},{"parent":"a9fa6f746c42","note":"对非主键建立的索引叫做辅助索引","children":[],"id":"fd86153c92fa","title":"辅助索引"}],"id":"a9fa6f746c42","title":"维度2"},{"parent":"f8a6f41949fc","children":[{"parent":"ba8befaae0da","note":"表中的某一个字段是唯一的且对这个字段建立了索引\n","children":[],"id":"f388e7b25b08","title":"唯一索引"},{"parent":"ba8befaae0da","note":"表中的某个字段不是唯一的且对这个字段建立了索引","children":[],"id":"4f2214e70289","title":"非唯一索引(普通索引)"}],"id":"ba8befaae0da","title":"维度3"},{"parent":"f8a6f41949fc","children":[{"parent":"660177bf1545","note":"对表中多个字段建立了索引","children":[],"id":"4bf6c2893da0","title":"联合索引"},{"parent":"660177bf1545","note":"对表中多个字段建立了索引且满足查找这个索引就能搜索出需要的数据","children":[],"id":"710eb0070af7","title":"覆盖索引"}],"id":"660177bf1545","title":"维度4"}],"id":"f8a6f41949fc","title":"B+树索引"},{"parent":"b5451044d06c","note":"即fulltext,是提高全文搜索速度的一种索引结构","children":[],"id":"8d1943eaa113","title":"全文索引"},{"parent":"b5451044d06c","note":"InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引","children":[],"id":"5d2121b58783","title":"哈希索引"}],"id":"b5451044d06c","title":"分类"}],"collapsed":false,"id":"5e109e24333d","title":"概述"},{"parent":"5d3eb4bc4bc7","children":[{"parent":"b8a10ac0a1b1","children":[{"parent":"d62e7652a0a1","note":"每张表只能拥有一个聚集索引,是对主键建立的索引","children":[],"id":"1c2b0adf6d85","title":"唯一"},{"parent":"d62e7652a0a1","note":"聚集索引的叶子节点称为数据页，因此在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。","children":[],"id":"5931cfbb2cf0","title":"数据页"},{"parent":"d62e7652a0a1","note":"聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描","children":[],"id":"7a9ea0b47ab2","title":"加快范围查询"}],"id":"d62e7652a0a1","title":"聚集索引"},{"parent":"b8a10ac0a1b1","children":[{"parent":"823213fdb266","note":"叶子节点并不包含行记录的全部数据,叶子节点除了包含键值以外,还包括相应行数据的聚集索引键","children":[],"id":"a1cec49e4071","title":"不是全部数据"},{"parent":"823213fdb266","note":"可以建立多个辅助索引","children":[],"id":"af120d44bfc3","title":"可以建立多个"},{"parent":"823213fdb266","note":"可能引起离散读的问题,但是一般的数据库都通过实现预读（read ahead）技术来避免多次的离散读操作","children":[],"id":"7060a8d18ef6","title":"可能引起离散读"}],"id":"823213fdb266","title":"辅助索引"},{"parent":"b8a10ac0a1b1","children":[{"parent":"50637520ece6","note":"可以对多个列进行建立联合索引,加快搜索速度","children":[],"id":"8e7553ffd2c7","title":"多列建立"},{"parent":"50637520ece6","note":"已经对第二个键值进行了排序处理。例如，在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引本身在叶子节点已经排序了","children":[],"id":"caf5f98b28cc","title":"有序"}],"id":"50637520ece6","title":"联合索引"},{"parent":"b8a10ac0a1b1","children":[{"parent":"04192f3c3740","note":"不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作","children":[],"id":"51c5fa006743","title":"比较小"},{"parent":"04192f3c3740","note":"对某些统计问题而言的,比如:SELECT COUNT(*) FROM tablename;InnoDB存储引擎并不会选择通过查询聚集索引来进行统计。由于buy_log表上还有辅助索引，而辅助索引远小于聚集索引，选择辅助索引可以减少IO操作","children":[],"id":"df8b26cfb13f","title":"统计优化"}],"id":"04192f3c3740","title":"覆盖索引"}],"id":"b8a10ac0a1b1","title":"特点"},{"parent":"5d3eb4bc4bc7","children":[{"parent":"82196b2f159c","children":[{"parent":"344d35635383","note":"如果一个字段，它可取值的范围很小，称为低选择性\n\n如果某个字段的取值范围很广，几乎没有重复，即属于高选择性","children":[],"id":"72b384ba2bc0","title":"高低选择性"},{"parent":"344d35635383","note":"表示索引中不重复记录数量的预估值","children":[],"id":"a85bb3ccdf03","title":"定义"},{"parent":"344d35635383","children":[{"parent":"497a01e0bee4","note":"通过采样法来完成:\n\n取得B+树索引中叶子节点的数量，记为A。\n\n随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。\n\n根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8）*A/8。","children":[],"id":"9d4e1571a655","title":"统计方式"},{"parent":"497a01e0bee4","note":"","children":[{"parent":"4126751b3057","note":"表中1/16的数据已发生过变化。\n\n表中发生变化的次数＞2 000 000 000","children":[],"id":"06ffe7d17817","title":"在insert和update满足一定条件时触发"},{"parent":"4126751b3057","note":"当执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎去重新计算索引的Cardinality值","children":[],"id":"4863c14a7bbe","title":"执行某些sql语句时"}],"id":"4126751b3057","title":"更新策略"}],"id":"497a01e0bee4","title":"统计原理"}],"id":"344d35635383","title":"Cardinality"},{"parent":"82196b2f159c","children":[{"parent":"c827eb2b1e21","children":[],"id":"8b3e37628901","title":"索引字段具有高选择性"},{"parent":"c827eb2b1e21","children":[],"id":"f50ea0929088","title":"从表中取出较少的数据"}],"id":"c827eb2b1e21","title":"建立索引的依据"}],"id":"82196b2f159c","title":"使用"},{"parent":"5d3eb4bc4bc7","children":[{"parent":"7378587afb69","note":"指的是模糊匹配,对于%开头的模糊匹配key,例如%key,索引会失效;但是形如key%,索引不会失效","children":[],"id":"f0a1dd03af1e","title":"模"},{"parent":"7378587afb69","note":"当sql语句where后使用的key数据类型和表中数据类型不一致时,索引会失效。比如where key = 1，表中key是vchar类型，索引会失效.这种工作中比较容易犯,应当重点注意","children":[],"id":"7ade51bd838f","title":"型"},{"parent":"7378587afb69","note":"指的是对索引的字段进行函数计算,比如形如where … avg(key)等，索引会失效","children":[],"id":"cae7b58c7648","title":"数"},{"parent":"7378587afb69","note":"指的是索引的字段在表中可能存在空值,索引会失效","children":[],"id":"2756372328ea","title":"空"},{"parent":"7378587afb69","note":"指的是对索引的字段进行相关的计算,例如加减等等,索引会失效","children":[],"id":"63739e128595","title":"运"},{"parent":"7378587afb69","note":"大名鼎鼎的联合索引最左匹配原则","children":[],"id":"ac701d78d95a","title":"最"},{"parent":"7378587afb69","note":"当sql优化器估测不使用索引更快时","children":[],"id":"e249e788b3e2","title":"快"},{"parent":"7378587afb69","note":"比如范围查询 join 等也可能会导致索引失效","children":[],"id":"3f73162b4fd7","title":"其他"}],"id":"7378587afb69","title":"索引失效"},{"parent":"5d3eb4bc4bc7","children":[{"parent":"0b22a47ce604","children":[{"parent":"1e72913ebc73","note":"MySQL5.6版本开始支持Multi-Range Read（MRR）优化。Multi-Range Read优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO-bound类型的SQL查询语句可带来性能极大的提升","children":[],"id":"7427454abdce","title":"定义"},{"parent":"1e72913ebc73","children":[{"parent":"6cca2b8cc8ec","children":[],"id":"702640a9e005","title":"range"},{"parent":"6cca2b8cc8ec","children":[],"id":"9a9c9f17e6d7","title":"ref"},{"parent":"6cca2b8cc8ec","children":[],"id":"fc5e30cd1bf8","title":"eq_ref"}],"id":"6cca2b8cc8ec","title":"适用范围"},{"parent":"1e72913ebc73","children":[{"parent":"cdab0093929d","children":[{"parent":"83d6ab3b02df","note":"在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。","children":[],"id":"ff0643fc0461","title":"使数据访问变得较为顺序"},{"parent":"83d6ab3b02df","children":[],"id":"4233f19f2543","title":"减少缓冲池中页被替换的次数"},{"parent":"83d6ab3b02df","children":[],"id":"9ced47848407","title":"批量处理对键值的查询操作"}],"id":"83d6ab3b02df","title":"原理"},{"parent":"cdab0093929d","children":[{"parent":"74adae9e5cd0","note":"将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的","children":[],"id":"d1a165bad57f","title":"存储辅助索引的键值并排序"},{"parent":"74adae9e5cd0","children":[],"id":"e5d4e9c780c4","title":"将缓存中的键值根据RowID进行排序"},{"parent":"74adae9e5cd0","children":[],"id":"22e3576624ea","title":"根据RowID的排序顺序来访问实际的数据文件"}],"id":"74adae9e5cd0","title":"算法过程"}],"id":"cdab0093929d","title":"优势"},{"parent":"1e72913ebc73","children":[{"parent":"4b49953934cb","note":"SELECT * FROM salaries WHERE salary＞10000 AND salary＜40000;\n\n先缓存满足条件的辅助索引键值，然后根据rowid进行排序，接着较为顺序的访问数据文件","children":[],"id":"25650fda9265","title":"使数据访问变得较为顺序"},{"parent":"4b49953934cb","note":"SELECT * FROM t WHERE key_part1＞=1000 AND key_part1＜2000 AND key_part2=1000;\n\n\n表t有（key_part1，key_part2）的联合索引，优化器会先将查询条件进行拆分，然后再进行数据查询同时会过滤不满足的数据。就上述查询语句而言，优化器会将查询条件拆分为（1000，1000），（1001，1000），（1002，1000），…，（1999，1000），最后再根据这些拆分出的条件进行数据的查询。","children":[],"id":"c033e5230560","title":"将范围查询拆分为键值对"}],"id":"4b49953934cb","title":"举例"}],"id":"1e72913ebc73","title":"Multi-Range&nbsp;Read(MRR)优化"},{"parent":"0b22a47ce604","children":[{"parent":"19471339b8ca","note":"MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能","children":[],"id":"78140e7adfbc","title":"定义"},{"parent":"19471339b8ca","note":"在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。","children":[],"id":"91ebc4fe8ef4","title":"优点"},{"parent":"19471339b8ca","note":"explain中Extra字段带有Using index condition 就是表示ICP优化","children":[],"id":"b4a4016996a0","title":"举例"}],"id":"19471339b8ca","title":"Index&nbsp;Condition&nbsp;Pushdown(ICP)优化"}],"id":"0b22a47ce604","title":"存储引擎优化"},{"parent":"5d3eb4bc4bc7","children":[{"parent":"5e3a6ce99de9","note":"是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术","children":[],"id":"fea79f5c2cf5","title":"定义"},{"parent":"5e3a6ce99de9","children":[{"parent":"979345712790","children":[],"id":"d763a71507bf","title":"每张表只能有一个全文检索的索引"},{"parent":"979345712790","children":[],"id":"1533b756ebe8","title":"由多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则"},{"parent":"979345712790","children":[],"id":"2b08b7fe5a36","title":"支持没有单词界定符(delimiter)的语言，如中文、日语、韩语等"}],"id":"979345712790","title":"使用限制"}],"id":"5e3a6ce99de9","title":"全文索引"}],"collapsed":false,"id":"5d3eb4bc4bc7","title":"索引"},{"parent":"1daebf3f4599","children":[{"parent":"b3d72eb56943","note":"协调多进程或者多线程并发访问共享资源的一种机制","children":[],"id":"07cae06c8790","title":"定义"},{"parent":"b3d72eb56943","children":[{"parent":"629100fcd327","children":[{"parent":"bd86eed19f76","note":"锁定的时间必须非常短","children":[],"id":"6046d1a73bd3","title":"特点"},{"parent":"bd86eed19f76","children":[{"parent":"d4c4691641e8","children":[],"id":"c0460aa87297","title":"互斥量"},{"parent":"d4c4691641e8","children":[],"id":"0c727a578482","title":"读写锁"}],"id":"d4c4691641e8","title":"分类"},{"parent":"bd86eed19f76","note":"共享资源","children":[],"id":"1e5868354b23","title":"操作对象"}],"id":"bd86eed19f76","title":"latch(闩锁(轻量级的锁))"},{"parent":"629100fcd327","children":[{"parent":"dbc53d812ff2","note":"commit和rollback后释放\n\n有死锁检测机制","children":[],"id":"68936a598578","title":"特点"},{"parent":"dbc53d812ff2","note":"事务","children":[],"id":"da5a15e2bd84","title":"操作对象"}],"id":"dbc53d812ff2","title":"lock(锁)"}],"id":"629100fcd327","title":"模型"},{"parent":"b3d72eb56943","children":[{"parent":"60a5cd6a565c","children":[{"parent":"8f34b3571b5f","children":[],"id":"62864d8c8df9","title":"共享锁"},{"parent":"8f34b3571b5f","children":[],"id":"e21ac2c93077","title":"排它锁"}],"id":"8f34b3571b5f","title":"行级锁"},{"parent":"60a5cd6a565c","children":[{"parent":"7885714d8aae","children":[],"id":"7f3d32558cad","title":"共享锁"},{"parent":"7885714d8aae","children":[],"id":"d473d9c54861","title":"排它锁"},{"parent":"7885714d8aae","children":[{"parent":"bdd1f67f796a","note":"事务有意向对表中的某些行加共享锁","children":[],"id":"50f076b1e206","title":"定义"},{"parent":"bdd1f67f796a","note":"","children":[{"parent":"1e4d53be8ab6","note":"如若想获取表中某些行的共享锁,必须先获取表的意向共享锁","children":[],"id":"8ee4325bc547","title":"行级共享锁前提"},{"parent":"1e4d53be8ab6","children":[],"id":"44841cf0740f","title":"与表级共享锁兼容"},{"parent":"1e4d53be8ab6","children":[],"id":"b473b7e40905","title":"与表级排它锁互斥"},{"parent":"1e4d53be8ab6","children":[],"id":"38c3e77c2c68","title":"不与行级共享锁互斥"},{"parent":"1e4d53be8ab6","children":[],"id":"1adf23e8de92","title":"不与行级排它锁互斥"},{"parent":"1e4d53be8ab6","children":[],"id":"a0ed93510671","title":"与意向排它锁兼容"}],"id":"1e4d53be8ab6","title":"特点"}],"id":"bdd1f67f796a","title":"意向共享锁"},{"parent":"7885714d8aae","children":[{"parent":"6a6003be08d7","note":"事务有意向对表中的某些行加排他锁","children":[],"id":"c02d11360170","title":"定义"},{"parent":"6a6003be08d7","note":"","children":[{"parent":"8680869d8ceb","note":"如若想获取表中某些行的排他锁,必须先获取表的意向排它锁","children":[],"id":"1c8d0c7beece","title":"行级排它锁前提"},{"parent":"8680869d8ceb","children":[],"id":"9e8ccebbf59e","title":"与表级共享锁互斥"},{"parent":"8680869d8ceb","children":[],"id":"070fc7a4e4a5","title":"与表级排它锁互斥"},{"parent":"8680869d8ceb","children":[],"id":"252bbbe7bfa2","title":"不与行级共享锁互斥"},{"parent":"8680869d8ceb","children":[],"id":"34d93eff754a","title":"不与行级排它锁互斥"},{"parent":"8680869d8ceb","children":[],"id":"8845c6534c7b","title":"与意向共享锁兼容"}],"id":"8680869d8ceb","title":"特点"}],"id":"6a6003be08d7","title":"意向排他锁"}],"id":"7885714d8aae","title":"表级锁"}],"id":"60a5cd6a565c","title":"类型"},{"parent":"b3d72eb56943","note":"按照正常的共享排它锁逻辑理解即可","children":[],"id":"a424dd19f1e3","title":"兼容性"},{"parent":"b3d72eb56943","children":[{"parent":"b39c42119265","note":"是指InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据","children":[],"id":"8b786199c567","title":"定义"},{"parent":"b39c42119265","note":"通过多版本并发控制(MVCC)实现","children":[],"id":"3cb543749a5f","title":"读取原理"},{"parent":"b39c42119265","children":[{"parent":"e8ed84afae8d","note":"非一致性读总是读取被锁定行的最新一份快照数据","children":[],"id":"3c746069b4b6","title":"READ&nbsp;COMMITTED"},{"parent":"e8ed84afae8d","note":"非一致性读总是读取事务开始时的行数据版本","children":[],"id":"835ef0f12d53","title":"REPEATABLE&nbsp;READ"}],"id":"e8ed84afae8d","title":"快照定义"},{"parent":"b39c42119265","note":"极大的提高了数据库的并发性","children":[],"id":"336cd1e1fa9e","title":"优点"}],"id":"b39c42119265","title":"一次性非锁定读"},{"parent":"b3d72eb56943","children":[{"parent":"9f891db2675b","note":"在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性","children":[],"id":"97af9b627369","title":"定义"},{"parent":"9f891db2675b","children":[{"parent":"cf8bfda5532d","children":[],"id":"0ec36eedff55","title":"SELECT&nbsp;…&nbsp;FOR&nbsp;UPDATE"},{"parent":"cf8bfda5532d","children":[],"id":"3bfb89babbc8","title":"SELECT&nbsp;…&nbsp;LOCK&nbsp;IN&nbsp;SHARE&nbsp;MODE"},{"parent":"cf8bfda5532d","children":[],"id":"7464aaeddf68","title":"注意事项:以上2种模式都需要在一个事务中"}],"id":"cf8bfda5532d","title":"分类"}],"id":"9f891db2675b","title":"一次性锁定读"},{"parent":"b3d72eb56943","children":[{"parent":"df0566c6f874","note":"单个行记录上的锁","children":[],"id":"d8fddcd10b35","title":"Record Lock"},{"parent":"df0566c6f874","note":"间隙锁,锁定一个范围,但是不包括记录本身","children":[{"parent":"15780871fc90","note":"1. 将事务的隔离级别设置为READ COMMITTED  \n\n\n2. 将参数innodb\\_locks\\_unsafe\\_for\\_binlog设置为1","children":[],"id":"16e0115f65c6","title":"关闭Gap Lock"}],"id":"15780871fc90","title":"Gap Lock"},{"parent":"df0566c6f874","note":"Record Lock + Gap Lock.锁定一个范围,并且锁定记录本身","children":[{"parent":"7be1300fbef4","note":"为了解决REPEATABLE READ级别下幻读问题","children":[],"id":"67f1e97b606b","title":"目的"},{"parent":"7be1300fbef4","note":"当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围","children":[],"id":"e40efd7aee09","title":"注意事项"}],"id":"7be1300fbef4","title":"Next-Key Lock"}],"id":"df0566c6f874","title":"行锁算法"},{"parent":"b3d72eb56943","children":[{"parent":"0a8d0c096d41","children":[{"parent":"7263f832ec5a","note":"在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据","children":[],"id":"d23897a0bc71","title":"定义"},{"parent":"7263f832ec5a","children":[{"parent":"15208f0e1d89","children":[],"id":"9c28a09c3840","title":"需要事务的隔离级别为READ&nbsp;UNCOMMITTED"},{"parent":"15208f0e1d89","children":[],"id":"b8cf3c8c45df","title":"别的事务修改数据但是未提交"}],"id":"15208f0e1d89","title":"产生条件"},{"parent":"7263f832ec5a","note":"事务的最少隔离级别为READ-COMMITTED","children":[],"id":"1b2c68d3f1d0","title":"解决办法"},{"parent":"7263f832ec5a","note":"例如replication环境中的slave节点，并且在该slave上的查询并不需要特别精确的返回值。","children":[],"id":"3830e586c5b7","title":"适用特例"}],"id":"7263f832ec5a","title":"脏读"},{"parent":"0a8d0c096d41","children":[{"parent":"b604ed87ddfa","children":[{"parent":"eb1ba869ef30","note":"在一个事务内两次读到的同一(行)数据是不一样的情况","children":[],"id":"3f1b49726817","title":"维基百科"},{"parent":"eb1ba869ef30","note":"将不可重复读的问题定义为Phantom Problem，即幻读问题。即在一个事务内两次读到的数据是不一样的情况(包括update、insert和delete)","children":[],"id":"a35ff6baa326","title":"mysql官方文档"}],"id":"eb1ba869ef30","title":"定义"},{"parent":"b604ed87ddfa","children":[{"parent":"043876daacaa","children":[],"id":"de8a41182e83","title":"事务的隔离级别最高为READ-COMMITTED"},{"parent":"043876daacaa","children":[],"id":"af30da8a5ece","title":"别的事务对同一(行)数据执行update并且已提交"}],"id":"043876daacaa","title":"产生条件"},{"parent":"b604ed87ddfa","note":"事务隔离级别最少是READ REPEATABLE，采用一致性非锁定读和Next-Key Lock算法避免不可重复读","children":[],"id":"bae631faa161","title":"解决办法"}],"id":"b604ed87ddfa","title":"不可重复读"},{"parent":"0a8d0c096d41","children":[{"parent":"b2dd7657c854","note":"维基百科中定义:当在事务过程中，另一事务向正在读取的记录添加或删除新行时，将发生幻像读取(读取的数据不一样)","children":[],"id":"02b92867902d","title":"定义"},{"parent":"b2dd7657c854","children":[{"parent":"9288088fc396","children":[],"id":"573d23dff15e","title":"事务的隔离级别最高为REPEATABLE-READ"},{"parent":"9288088fc396","children":[],"id":"a139f06593a5","title":"别的事务进行insert或者delete操作，并且已提交"}],"id":"9288088fc396","title":"产生条件"},{"parent":"b2dd7657c854","note":"","children":[{"parent":"7aaf29d8fb72","children":[],"id":"a2b5c6985e34","title":"将事务的隔离级别最少提升至REPEATABLE-READ"},{"parent":"7aaf29d8fb72","children":[],"id":"9af2b4e96d6d","title":"采用Next-Key&nbsp;Lock算法"},{"parent":"7aaf29d8fb72","children":[],"id":"522a3c9b86c2","title":"mysql的REPEATABLE-READ级别下采用了Next-Key Lock算法,所以mysql的该级别下解决了幻读问题"}],"id":"7aaf29d8fb72","title":"解决办法"}],"id":"b2dd7657c854","title":"幻读"},{"parent":"0a8d0c096d41","children":[{"parent":"be3914d63960","note":"简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。\n注意:理解上面的定义关键在于,mysql数据库Innodb默认的数据库隔离级别是:REPEATABLE-READ,T1 T2事务采取一致性非锁定读, 读取的是事务开始时的行数据版本.","children":[],"id":"4a57a83bbf63","title":"定义"},{"parent":"be3914d63960","children":[{"parent":"9139915757f7","children":[],"id":"f5fc40bad5c4","title":"需要事务的隔离级别最高为REPEATABLE-READ"},{"parent":"9139915757f7","children":[],"id":"ecdb19b30d9b","title":"采用一致性非锁定读的方式读取事务开始时的数据"}],"id":"9139915757f7","title":"产生条件"},{"parent":"be3914d63960","children":[{"parent":"798753aa2383","children":[],"id":"cf1865f1e5e2","title":"加上排它锁,将T1&nbsp;和&nbsp;T2事务串行化"},{"parent":"798753aa2383","children":[],"id":"f64b4d31aba8","title":"将数据库隔离级提升至SERIALIZABLE"}],"id":"798753aa2383","title":"解决办法"}],"id":"be3914d63960","title":"丢失更新"}],"id":"0a8d0c096d41","title":"锁问题"},{"parent":"b3d72eb56943","children":[{"parent":"552d049c4451","note":"是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去","children":[],"id":"dedc502bda4f","title":"定义"},{"parent":"552d049c4451","children":[{"parent":"adaa4e05ed4a","note":"A事务在等待B事务，B事务在等待A事务.","children":[],"id":"fb8f370a2167","title":"AB-BA死锁"},{"parent":"adaa4e05ed4a","children":[],"id":"045444a326d8","title":"事务持有X锁又请求S锁"}],"id":"adaa4e05ed4a","title":"msyql中死锁分类"},{"parent":"552d049c4451","children":[{"parent":"2791337ba1a4","note":"即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行\n\n有2个字段可以设置:\ninnodb\\_lock\\_wait\\_timeout\n\ninnodb\\_rollback\\_on\\_timeout","children":[],"id":"fd124ed6f44b","title":"等待超时"},{"parent":"2791337ba1a4","children":[{"parent":"cba7286c537b","note":"一种更为主动的死锁检测方式","children":[],"id":"e30659929b9c","title":"特点"},{"parent":"cba7286c537b","note":"wait-for graph要求数据库保存以下两种信息：\n\n锁的信息链表\n事务等待链表\n\n\n通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。","children":[],"id":"4664f7e5bb43","title":"原理"}],"id":"cba7286c537b","title":"wait-for&nbsp;graph(等待图)"}],"id":"2791337ba1a4","title":"解决方式"}],"id":"552d049c4451","title":"死锁"}],"collapsed":false,"id":"b3d72eb56943","title":"锁"},{"parent":"1daebf3f4599","children":[{"parent":"d52743f97ad9","note":"是访问并更新数据库各种数据项的一个程序执行单元,要么都做修改 要么都不做","children":[],"id":"8486786ac0fb","title":"定义"},{"parent":"d52743f97ad9","children":[{"parent":"60bef62e7acc","note":"简单来说 要么都做 要么都不做","children":[],"id":"72ffd4ddc29f","title":"原子性(atomicity)"},{"parent":"60bef62e7acc","note":"一致性是指事务将数据库从一种状态转变为下一种一致的状态,在事务开始之前和事务结束之后,数据库的完整性约束没有被破坏","children":[],"id":"9f6bf2f6b183","title":"一致性(Consistency)"},{"parent":"60bef62e7acc","note":"每个事务的操作对象都能够分离，即事务提交前对其他事务都不可见","children":[],"id":"a43473fa5755","title":"隔离性(Isolation)"},{"parent":"60bef62e7acc","note":"事务一旦提交,其结果就是永久性的，即使数据库宕机 数据也能恢复","children":[],"id":"5b6e282860d1","title":"持久性(duraibility)"}],"id":"60bef62e7acc","title":"事务ACID特性"},{"parent":"d52743f97ad9","children":[{"parent":"16f307bdb1b6","children":[],"id":"e30e32b95932","title":"锁事务的隔离性"},{"parent":"16f307bdb1b6","children":[],"id":"3b0c6bdc9c74","title":"redo log实现事务的原子性和持久性"},{"parent":"16f307bdb1b6","children":[],"id":"7710a0cb60c3","title":"undo log实现事务的一致性"}],"id":"16f307bdb1b6","title":"事务实现原理"},{"parent":"d52743f97ad9","children":[{"parent":"257957bf2ae1","children":[],"id":"29c395726135","title":"QPS(Question Per Second)：每秒请求数"},{"parent":"257957bf2ae1","children":[],"id":"c4885ec622bb","title":"TPS(Transaction Per Second)：每秒事务处理能力"},{"parent":"257957bf2ae1","children":[{"parent":"183f182a2973","note":"利用这种方法进行计算的前提是：所有的事务必须都是显式提交的，如果存在隐式地提交和回滚（默认autocommit=1），不会计算到com\\_commit和com\\_rollback变量中","children":[],"id":"b4f22c5f4802","title":"(com_commit +&nbsp;com_rollback)/time"},{"parent":"183f182a2973","note":"在MySQL 5.1中可以很好地用来统计InnoDB存储引擎显式和隐式的事务提交操作，但是在InnoDB Plugin中这两个参数的表现有些“怪异”，并不能很好地统计事务的次数","children":[],"id":"c3b209067f98","title":"handler_commit和handler_rollback"}],"id":"183f182a2973","title":"统计方法"}],"id":"257957bf2ae1","title":"事务统计"},{"parent":"d52743f97ad9","children":[{"parent":"1f7d5f7b724d","children":[],"id":"51c7f1ae3a13","title":"READ&nbsp;UNCOMMITTED"},{"parent":"1f7d5f7b724d","children":[],"id":"ca203d9626c0","title":"READ&nbsp;COMMITTED"},{"parent":"1f7d5f7b724d","children":[],"id":"9451bf9ecb14","title":"REPEATABLE&nbsp;READ"},{"parent":"1f7d5f7b724d","children":[],"id":"b9a23d842566","title":"SERIALIZABLE"}],"id":"1f7d5f7b724d","title":"事务隔离级别"},{"parent":"d52743f97ad9","children":[{"parent":"79c63e0a507c","children":[{"parent":"c98f7eb0b46f","children":[],"id":"ee4071d92003","title":"InnoDB事务隔离级别必须是SERIALIZABLE"},{"parent":"c98f7eb0b46f","children":[],"id":"3775d11da266","title":"参与在全局事务中的每个节点都支持XA事务"}],"id":"c98f7eb0b46f","title":"条件"},{"parent":"79c63e0a507c","children":[{"parent":"16281b469fe7","note":"通常就是各种数据库","children":[],"id":"9f1374ab7e6c","title":"资源管理器"},{"parent":"16281b469fe7","note":"协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信","children":[],"id":"6d3897572706","title":"事务管理器"},{"parent":"16281b469fe7","note":"定义事务的边界，指定全局事务中的操作","children":[],"id":"0c2ad2d8332d","title":"应用程序"}],"id":"16281b469fe7","title":"XA事务组成"},{"parent":"79c63e0a507c","children":[{"parent":"6c127573b0b3","note":"所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了","children":[],"id":"8b8ed3f99d65","title":"第一阶段"},{"parent":"6c127573b0b3","note":"事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交","children":[],"id":"e858812e8268","title":"第二阶段"}],"id":"6c127573b0b3","title":"两阶段提交"}],"id":"79c63e0a507c","title":"分布式事务"},{"parent":"d52743f97ad9","children":[{"parent":"a23d60cd7745","children":[],"id":"6581838deac7","title":"在循环中提交事务"},{"parent":"a23d60cd7745","children":[],"id":"34bf62c61db6","title":"使用自动提交"},{"parent":"a23d60cd7745","children":[],"id":"6f1febd80c97","title":"使用自动回滚"},{"parent":"a23d60cd7745","children":[],"id":"e6283d5b5722","title":"使用长事务"}],"id":"a23d60cd7745","title":"不好的事务习惯"}],"collapsed":false,"id":"d52743f97ad9","title":"事务"},{"parent":"1daebf3f4599","children":[{"parent":"306b5f8b33b6","children":[{"parent":"9b5fec1751f3","children":[{"parent":"86c7799633af","note":"是指备份操作是在数据库停止的情况下，这种备份最为简单，一般只需要复制相关的数据库物理文件即可","children":[],"id":"63cecb9a9d54","title":"冷备"},{"parent":"86c7799633af","note":"是在数据库运行中进行的，但是会对当前数据库的操作有所影响，如加一个全局读锁以保证备份数据的一致性","children":[],"id":"a8c7baa87787","title":"温备"},{"parent":"86c7799633af","note":"是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响","children":[],"id":"df86fa4ea96c","title":"热备"}],"id":"86c7799633af","title":"按备份方式"},{"parent":"9b5fec1751f3","children":[{"parent":"a38ff029fc3a","note":"是指备份出的文件内容是可读的，一般是文本文件。内容一般是由一条条SQL语句，或者是表内实际数据组成","children":[],"id":"c6401217e7d7","title":"逻辑备份"},{"parent":"a38ff029fc3a","note":"是指复制数据库的物理文件，既可以是在数据库运行中的复制（如ibbackup、xtrabackup这类工具），也可以是在数据库停止运行时直接的数据文件复制","children":[],"id":"ab3cf9ff194e","title":"裸文件备份"}],"id":"a38ff029fc3a","title":"按备份文件的内容"},{"parent":"9b5fec1751f3","children":[{"parent":"3311bfda3788","note":"是指对数据库进行一个完整的备份","children":[],"id":"d7d96ae9aab1","title":"完全备份"},{"parent":"3311bfda3788","note":"是指在上次完全备份的基础上，对于更改的数据进行备份","children":[],"id":"06aa06cb255f","title":"增量备份"},{"parent":"3311bfda3788","note":"是指对MySQL数据库二进制日志的备份，通过对一个完全备份进行二进制日志的重做（replay）来完成数据库的point-in-time的恢复工作","children":[],"id":"971762cc4456","title":"日志备份"}],"id":"3311bfda3788","title":"按备份数据库的内容"}],"id":"9b5fec1751f3","title":"备份方式分类"},{"parent":"306b5f8b33b6","children":[{"parent":"11eeb7d7ea2a","children":[{"parent":"0cbbafc328c0","note":"只需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.ibd），重做日志文件。另外建议定期备份MySQL数据库的配置文件my.cnf，这样有利于恢复的操作","children":[],"id":"9fd2dfc60f67","title":"备份方式"},{"parent":"0cbbafc328c0","note":"备份简单，只要复制相关文件即可。\n备份文件易于在不同操作系统，不同MySQL版本上进行恢复。\n恢复相当简单，只需要把文件恢复到指定位置即可。\n恢复速度快，不需要执行任何SQL语句，也不需要重建索引。","children":[],"id":"7eebf829a3d6","title":"优点"},{"parent":"0cbbafc328c0","note":"InnoDB存储引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。\n冷备也不总是可以轻易地跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式都会成为问题。","children":[],"id":"b398214ab67b","title":"缺点"}],"id":"0cbbafc328c0","title":"冷备"},{"parent":"11eeb7d7ea2a","children":[{"parent":"6870021435fa","children":[],"id":"abc5d454a48e","title":"ibbackup"},{"parent":"6870021435fa","children":[],"id":"ece139b52500","title":"xtrabackup"}],"id":"6870021435fa","title":"热备"},{"parent":"11eeb7d7ea2a","children":[{"parent":"a844a15bb872","children":[{"parent":"5a69a03d75ae","children":[],"id":"988661edc97f","title":"mysqldump"},{"parent":"5a69a03d75ae","children":[],"id":"62312735db40","title":"SELECT&nbsp;…&nbsp;INTO&nbsp;OUTFILE"}],"id":"5a69a03d75ae","title":"备份"},{"parent":"a844a15bb872","children":[{"parent":"e760b7f7e9db","note":"示例:shell &gt;  mysql -uroot -p &lt; dump.sql","children":[],"id":"0eb84640cf4c","title":"mysql"},{"parent":"e760b7f7e9db","note":"示例:mysql&gt; source ~/test/dump.sql;","children":[],"id":"a33d5ea74cc2","title":"source"},{"parent":"e760b7f7e9db","children":[],"id":"1c720e76d60f","title":"LOAD&nbsp;DATA&nbsp;INFILE"},{"parent":"e760b7f7e9db","children":[],"id":"fd738e1ff5de","title":"mysqlimport"}],"id":"e760b7f7e9db","title":"恢复"}],"id":"a844a15bb872","title":"逻辑备份与恢复"},{"parent":"11eeb7d7ea2a","children":[],"id":"2c4baade13b8","title":"二进制日志备份与恢复"},{"parent":"11eeb7d7ea2a","children":[],"id":"4b64c12e7da5","title":"快照备份"},{"parent":"11eeb7d7ea2a","image":{"w":900,"h":552.5667351129364,"url":"http://cdn.processon.com/63009b53e0b34d68ef53f2d8?e=1660987747&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:tjzfAdZ-XG0Xy9XkyYUqut1NOIg=","direction":"up"},"children":[],"id":"80a01305fa45","title":"复制 + 快照备份架构"}],"collapsed":false,"id":"11eeb7d7ea2a","title":"备份方式"}],"collapsed":false,"id":"306b5f8b33b6","title":"备份与恢复"},{"parent":"1daebf3f4599","children":[{"parent":"6d83a7833e42","note":"1.选择64位多核CPU\n2.增大读写线程个数\n3.OLAP属于CPU密集型","children":[],"id":"e4d4e3abaf42","title":"CPU选择"},{"parent":"6d83a7833e42","note":"提前预估活跃的数据量的大小,尽量选择大的内存","children":[],"id":"a43b09799fe1","title":"内存选择"},{"parent":"6d83a7833e42","children":[{"parent":"08ce5574ad66","note":"传统机械硬盘顺序访问远高于随机访问\n固态硬盘读写是非对称的，读取速度大于写入速度","children":[],"id":"e6c658b394a6","title":"传统机械VS固态"},{"parent":"08ce5574ad66","children":[{"parent":"55725781ea3c","note":"innodb\\_io\\_capacity:用来当刷新脏数据时，控制MySQL每秒执行的写IO量。\n如果是固态硬盘，考虑适当增大innodb\\_io\\_capacity,充分利用固态硬盘带来的高IOPS特性","children":[],"id":"014b842c3626","title":"考虑innodb_io_capacity参数"},{"parent":"55725781ea3c","note":"工作原理:当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。\n优点:通过AIO可以将多个IO写入操作合并为一个IO操作,故该工作机制在传统机械磁盘下有着显著的优势。\n\n传统机械键盘要开启该特性，固态硬盘可以选择关闭邻接页的刷新","children":[],"id":"87513ba06695","title":"考虑关闭邻接页的刷新"},{"parent":"55725781ea3c","children":[],"id":"2884b505d660","title":"OLTP选择固态"}],"id":"55725781ea3c","title":"调优方式"}],"id":"08ce5574ad66","title":"硬盘选择"},{"parent":"6d83a7833e42","children":[{"parent":"e4575616eec8","children":[{"parent":"6b6ae6c62046","note":"RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）的基本思想就是把多个相对便宜的硬盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。","children":[],"id":"becfef7190b8","title":"定义"},{"parent":"6b6ae6c62046","note":"增强数据集成度\n增强容错功能\n增加处理量或容量","children":[],"id":"bab9b8375583","title":"作用"}],"id":"6b6ae6c62046","title":"RAID"},{"parent":"e4575616eec8","children":[{"parent":"147481f87dc5","note":"RAID Write Back功能是指RAID控制器能够将写入的数据放入自身的缓存中，并把它们安排到后面再执行","children":[],"id":"9269a2df6416","title":"定义"},{"parent":"147481f87dc5","note":"不用等待物理磁盘实际写入的完成，因此写入变得更快了。对于数据库来说，这显得十分重要。","children":[],"id":"f2ca11116b12","title":"优点"}],"id":"147481f87dc5","title":"RAID&nbsp;Write&nbsp;Back"},{"parent":"e4575616eec8","children":[{"parent":"614544d51595","note":"优点:读取与写入速度快,有镜像备份,可靠性高\n缺点:当一个磁盘失效时，性能可能会受到很大的影响，因为条带（strip）会成为瓶颈。","children":[],"id":"7deb062ab8a3","title":"选择RAID10"},{"parent":"614544d51595","children":[],"id":"5b5373e1995f","title":"视情况开启RAID&nbsp;Write&nbsp;Back功能"}],"id":"614544d51595","title":"调优方式"}],"id":"e4575616eec8","title":"合理设置RAID"},{"parent":"6d83a7833e42","note":"使用64位的操作系统，并且使用64位mysql","children":[],"id":"2cc09c7a9cda","title":"操作系统选择"},{"parent":"6d83a7833e42","note":"选择适合数据库的文件系统,比如支持快照等等","children":[],"id":"54615ec7cbf2","title":"文件系统选择"},{"parent":"6d83a7833e42","children":[{"parent":"ed0da66534eb","note":"sysbench是一个模块化的、跨平台的多线程基准测试工具，主要用于测试各种不同系统参数下的数据库负载情况。","children":[],"id":"b1814c288656","title":"sysbench"},{"parent":"ed0da66534eb","note":"用来测试典型的复杂OLTP（在线事务处理）系统的性能","children":[],"id":"44932d9c740b","title":"tpcc-mysql"}],"id":"ed0da66534eb","title":"基准测试工具的选择"}],"collapsed":false,"id":"6d83a7833e42","title":"性能调优"},{"parent":"1daebf3f4599","children":[],"id":"7d1264cfe4fc","title":"集群"}],"collapsed":false,"id":"1daebf3f4599","title":"高级"}],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"f9a71ca6f472","note":"#### sudo apt install mysql-server\n#### sudo apt install mysql-client","children":[],"id":"1019c9c21506","title":"mysql安装"},{"parent":"f9a71ca6f472","image":{"w":900,"h":611.1111111111111,"url":"http://cdn.processon.com/623308517d9c08076d11888f?e=1647515234&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:rHRk24W_sOpFwIvD1EGX7UQDtqE="},"children":[],"id":"0bea17ffeed5","title":""},{"parent":"f9a71ca6f472","note":"","image":{"w":900,"h":631.1894273127754,"url":"http://cdn.processon.com/623309297d9c08076d118ba0?e=1647515450&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:byzsYSoF_BfNYJcP24ky8QOiLKw="},"children":[],"id":"ae208286a79b","title":""},{"parent":"f9a71ca6f472","children":[{"parent":"1712cecfa6a5","children":[{"parent":"a1f32b3676b3","image":{"w":884,"h":528,"url":"http://cdn.processon.com/62330a22f346fb07f935be8b?e=1647515699&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6juRUiBZyhNVtxEKhLC1gIORn28="},"children":[],"id":"c59dea2fc856","title":""},{"parent":"a1f32b3676b3","note":"后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。","children":[{"parent":"d61b839e33ba","note":"Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等","children":[],"id":"72ae2469bcb9","title":"Master&nbsp;Thread"},{"parent":"d61b839e33ba","note":"在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理","children":[],"id":"babb9f802654","title":"IO&nbsp;Thread"},{"parent":"d61b839e33ba","note":"事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页","children":[],"id":"9861857c9f65","title":"Purge&nbsp;Thread"},{"parent":"d61b839e33ba","note":"Page Cleaner Thread是在InnoDB 1.2.x版本中引入的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能","children":[],"id":"005063c4df7c","title":"Page&nbsp;Cleaner&nbsp;Thread"}],"collapsed":false,"id":"d61b839e33ba","title":"后台线程"},{"parent":"a1f32b3676b3","children":[{"parent":"510b3ae36c4e","note":"由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能","children":[{"parent":"6fcc508bc27f","children":[],"id":"d3f5a9e547d7","title":"索引页"},{"parent":"6fcc508bc27f","children":[],"id":"97e7d0ba332d","title":"数据页"},{"parent":"6fcc508bc27f","children":[],"id":"d2b992a14036","title":"undo页"},{"parent":"6fcc508bc27f","children":[],"id":"6b07bbe78379","title":"插入缓冲"},{"parent":"6fcc508bc27f","children":[],"id":"9e15323d36e8","title":"自适应哈希索引"},{"parent":"6fcc508bc27f","children":[],"id":"8cb0a8173c5d","title":"InnoDB存储的锁信息"},{"parent":"6fcc508bc27f","children":[],"id":"5a1a53280058","title":"数据字典信息"}],"id":"6fcc508bc27f","title":"缓冲池"},{"parent":"510b3ae36c4e","note":"InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件","children":[],"id":"3d9187dc649b","title":"重做日志缓冲"},{"parent":"510b3ae36c4e","note":"在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。例如，分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象（buffer control block），这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，在申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n","children":[],"id":"2fa8bc313fc0","title":"额外的缓冲池"},{"parent":"510b3ae36c4e","image":{"w":900,"h":374.78753541076486,"url":"http://cdn.processon.com/62332aed0e3e7407da53f210?e=1647524093&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:8wmXq41JpIlmKFAGHFyR7CH2ZWg="},"children":[],"id":"8845a807decb","title":""}],"collapsed":false,"id":"510b3ae36c4e","title":"内存池"}],"collapsed":false,"id":"a1f32b3676b3","title":"概述"},{"parent":"1712cecfa6a5","children":[{"parent":"542bfc5912e0","children":[{"parent":"26f895c28056","children":[{"parent":"4d563583544e","note":"在LRU列表中引入midpoint点(位于LRU首5/8处,可配置),把midpoint之后的列表称为old列表，之前的列表称为new列表。","children":[],"id":"12a9bb673719","title":"midpoint"},{"parent":"4d563583544e","note":"引入innodb_old_blocks_time，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端","children":[],"id":"46b0d3b5a676","title":"innodb_old_blocks_time"}],"id":"4d563583544e","title":"改进版LRU策略"},{"parent":"26f895c28056","children":[{"parent":"09890ec89cb6","note":"对于索引或数据的扫描操作，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘","children":[],"id":"ae89bc0abe90","title":"避免非活跃数据将活跃数据挤出缓冲池"},{"parent":"09890ec89cb6","note":"对于索引或数据的扫描操作，并不是活跃的热点数据。尽可能降低使热点数据被刷出的可能","children":[],"id":"6709e5d85bbf","title":"通过引入innodb_old_blocks_time,尽可能降低使LRU列表中热点数据被刷出的可能"}],"id":"09890ec89cb6","title":"优势"}],"id":"26f895c28056","title":"LRU&nbsp;List管理"},{"parent":"542bfc5912e0","children":[{"parent":"ac17ca15f406","note":"LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young","children":[],"id":"0392ea47cd65","title":"概述"}],"id":"ac17ca15f406","title":"Free&nbsp;List管理"},{"parent":"542bfc5912e0","children":[{"parent":"a185f6420b93","note":"在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。","children":[],"id":"c172c2c45fce","title":"概述"}],"id":"a185f6420b93","title":"Flush&nbsp;List管理"}],"collapsed":false,"id":"542bfc5912e0","title":"内存管理策略"},{"parent":"1712cecfa6a5","children":[{"parent":"b85f739b5f79","children":[{"parent":"1f7ef6a18204","children":[{"parent":"f04bd4b26cfc","note":"对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，","children":[],"id":"76ac383fb8ac","title":"定义"},{"parent":"f04bd4b26cfc","children":[{"parent":"4912227b472b","note":"对于非聚集索引页不在缓冲池中先不插入,而是放入insert buff中,然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。","children":[],"id":"da2baed1ce77","title":"优势"},{"parent":"4912227b472b","note":"Insert Buffer中如果有大量数据,若此时MySQL数据库发生了宕机，这时势必有大量的Insert Buffer并没有合并到实际的非聚集索引中去。因此这时恢复可能需要很长的时间，在极端情况下甚至需要几个小时","children":[],"id":"08f4112009af","title":"劣势"}],"id":"4912227b472b","title":"优劣势"}],"id":"f04bd4b26cfc","title":"Insert Buff"},{"parent":"1f7ef6a18204","children":[{"parent":"662361e762c4","note":"InnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge buffer。","children":[],"id":"55e7f52db00e","title":"定义"},{"parent":"662361e762c4","note":"1.索引是辅助索引\n2.索引不是唯一的","children":[],"id":"dba181e14cd6","title":"使用条件"},{"parent":"662361e762c4","note":"innodb_change_buffering\n该参数可选的值为：inserts、deletes、purges、changes、all、none。inserts、deletes、purges就是前面讨论过的三种情况。changes表示启用inserts和deletes，all表示启用所有，none表示都不启用。该参数默认值为all。","children":[],"id":"0e00fdc72b4f","title":"开启"}],"id":"662361e762c4","title":"Change Buff"},{"parent":"1f7ef6a18204","children":[{"parent":"ccd7f321874d","note":"如果辅助索引页被读取到缓冲池中时，通过Insert Buffer Bitmap页确认该辅助索引页是否有记录存放于Insert Buffer B+树中,如果有,则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。\n","children":[],"id":"2f0fbb134681","title":"辅助索引页被读取到缓冲池中"},{"parent":"ccd7f321874d","note":"Insert Buffer Bitmap页追踪到该辅助索引页插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。","children":[],"id":"441c5bbd5973","title":"该辅助索引页已剩余存储空间少于1/32时"},{"parent":"ccd7f321874d","note":"在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作。","children":[{"parent":"8bfddfc868d9","children":[{"parent":"a6a7603370e7","note":"根据srv_innodb_io_capactiy的百分比来决定真正要合并多少个辅助索引页","children":[],"id":"c9ac0f5e0512","title":"srv_innodb_io_capactiy"},{"parent":"a6a7603370e7","note":"随机地选择Insert Buffer B+树的一个页，读取该页中的space及之后所需要数量的页。该算法在复杂情况下应有更好的公平性。","children":[],"id":"e00181f3bbc5","title":"算法思想"}],"id":"a6a7603370e7","title":"Master&nbsp;Thread&nbsp;Merge&nbsp;算法"}],"id":"8bfddfc868d9","title":"Master&nbsp;Thread机制"}],"id":"ccd7f321874d","title":"Merge&nbsp;Insert&nbsp;Buffer"}],"collapsed":false,"id":"1f7ef6a18204","title":"插入缓冲"},{"parent":"b85f739b5f79","children":[{"parent":"237acc59492c","note":"InnoDB存储引擎中有页的副本doublewrite Buffer,每次写入数据时，先写入共享表空间的物理磁盘上(顺序写),然后在写入页的各个表空间文件中(ibd 离散写)","children":[],"id":"f387e92e6258","title":"定义"},{"parent":"237acc59492c","note":"提升数据页的可靠性。\n当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效(partial page write)。\n如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，重做日志中记录的是对页的物理操作，如偏移量800，写’aaaa’记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。","children":[],"id":"c132e5d1aeef","title":"特性"},{"parent":"237acc59492c","note":"在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的","children":[],"id":"ab86ea95409a","title":"流程"},{"parent":"237acc59492c","children":[{"parent":"bf36e28ef4ea","note":"mysql＞SHOW GLOBAL STATUS LIKE&#39;innodb_dblwr%&#39;\\G;","children":[],"id":"8a9bea3df5dc","title":"查看doublewrite运行情况"},{"parent":"bf36e28ef4ea","note":"mysql&gt; show variables like &#39;innodb_doublewrite&#39;;","children":[],"id":"f2057e2b0228","title":"doublewrite开启与关闭"}],"id":"bf36e28ef4ea","title":"命令"},{"parent":"237acc59492c","children":[{"parent":"f2348ffe885d","note":"如果用户有多个从服务器（slave server），需要提供较快的性能（如在slaves erver上做的是RAID0），也许启用这个参数是一个办法。不过对于需要提供数据高可靠性的主服务器（master server），任何时候用户都应确保开启doublewrite功能","children":[],"id":"6960087c380b","title":"master-slaves"},{"parent":"f2348ffe885d","note":"有的文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统。在这种情况下，用户就不要启用doublewrite了","children":[],"id":"112e0e82807b","title":"文件系统提供防范写失效"}],"id":"f2348ffe885d","title":"注意事项"},{"parent":"237acc59492c","image":{"w":900,"h":602.6706231454006,"url":"http://cdn.processon.com/6255702be401fd072e08af8c?e=1649770044&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:LNrYlWx3HcdeWsgYR4m9010xWbQ="},"children":[],"id":"660388ac5f4c","title":""}],"collapsed":false,"id":"237acc59492c","title":"两次写"},{"parent":"b85f739b5f79","children":[{"parent":"90bd073ab020","note":"InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）","children":[],"id":"4266035c6c2f","title":"定义"},{"parent":"90bd073ab020","children":[{"parent":"e27d02c16ffe","note":"AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快","children":[],"id":"26683086fccc","title":"建立速度非常快"},{"parent":"e27d02c16ffe","children":[],"id":"fdd40c9a95e3","title":"不需要对整张表构建哈希索引"},{"parent":"e27d02c16ffe","note":"InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引","children":[],"id":"63957ad0a608","title":"自动建立"}],"id":"e27d02c16ffe","title":"特点"},{"parent":"90bd073ab020","children":[{"parent":"0e298317e374","children":[],"id":"d779c7e77c07","title":"对这个页的连续访问模式必须是一样的"},{"parent":"0e298317e374","children":[],"id":"c2828a538720","title":"以该模式访问了100次<br>"},{"parent":"0e298317e374","children":[],"id":"bfafcf089049","title":"页通过该模式访问了N次，其中N=页中记录*1/16"}],"id":"0e298317e374","title":"建立AHI条件"},{"parent":"90bd073ab020","children":[{"parent":"140b912bbc45","note":"提升2倍","children":[],"id":"92ecd045fafc","title":"读取速度"},{"parent":"140b912bbc45","note":"提升2倍","children":[],"id":"a38fb4de994c","title":"写入速度"},{"parent":"140b912bbc45","note":"提升5倍","children":[],"id":"3a889eb6a64f","title":"辅助索引的连接性能"}],"id":"140b912bbc45","title":"效果"},{"parent":"90bd073ab020","children":[{"parent":"0aee918cde2d","note":"mysql&gt; show variables like &#39;innodb_adaptive_hash_index&#39;;","children":[],"id":"32ac1e6541f6","title":"AHI开启和关闭"},{"parent":"0aee918cde2d","note":"mysql＞SHOW ENGINE INNODB STATUS\\G;","children":[],"id":"ff0d9630d636","title":"查看AHI使用情况"}],"id":"0aee918cde2d","title":"命令"},{"parent":"90bd073ab020","note":"哈希索引只能用来搜索等值的查询，如SELECT*FROM table WHERE index_col=‘xxx’。而对于其他查找类型，如范围查找，是不能使用哈希索引的","children":[],"id":"dd50c5e5a330","title":"注意事项"}],"collapsed":false,"id":"90bd073ab020","title":"自适应哈希索引"},{"parent":"b85f739b5f79","children":[{"parent":"023ef08a9983","children":[{"parent":"1e90e5021c3c","note":"即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作","children":[],"id":"f5fe982c0388","title":"同步IO"},{"parent":"1e90e5021c3c","note":"发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成.","children":[],"id":"ba6b11364e52","title":"异步IO"},{"parent":"1e90e5021c3c","note":"内核级别提供的AIO支持","children":[],"id":"e127940e76fc","title":"Native&nbsp;AIO"}],"collapsed":false,"id":"1e90e5021c3c","title":"分类"},{"parent":"023ef08a9983","children":[{"parent":"ac4d76ee6be2","note":"用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，缩短了时间","children":[],"id":"c8db85fc2a73","title":"缩短了IO时间"},{"parent":"ac4d76ee6be2","note":"可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能.\n例如用户需要访问页的（space，page_no）为：（8，6）、（8，7），（8，8）\n每个页的大小为16KB，那么同步IO需要进行3次IO操作。而AIO会判断到这三个页是连续的（显然可以通过（space，page_no）得知）。因此AIO底层会发送一个IO请求，从（8，6）开始，读取48KB的页。","children":[],"id":"1b304672db76","title":"IO合并"}],"id":"ac4d76ee6be2","title":"异步IO优势"},{"parent":"023ef08a9983","children":[{"parent":"1834bfcc446d","note":"通过innodb_use_native_aio参数来控制","children":[],"id":"51a37cd6091d","title":"开启"}],"id":"1834bfcc446d","title":"Native AIO"},{"parent":"023ef08a9983","children":[{"parent":"6f21792637b0","children":[],"id":"2b78d51a801b","title":"read ahead"},{"parent":"6f21792637b0","children":[],"id":"81aaa4edce75","title":"脏页刷新"},{"parent":"6f21792637b0","children":[],"id":"0ea01cc58788","title":"磁盘写入"}],"id":"6f21792637b0","title":"在InnoDB中作用"}],"collapsed":false,"id":"023ef08a9983","title":"异步IO"},{"parent":"b85f739b5f79","children":[{"parent":"074b52398902","note":"当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。","children":[],"id":"c7787ded49e0","title":"定义"},{"parent":"074b52398902","note":"通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势","children":[],"id":"0f9307595864","title":"优势"},{"parent":"074b52398902","children":[{"parent":"de5522938406","note":"通过innodb_flush_neighbors进行控制","children":[],"id":"a0d49d127849","title":"命令"},{"parent":"de5522938406","note":"对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性","children":[],"id":"f2fa200421d1","title":"注意事项"}],"id":"de5522938406","title":"开启和关闭"}],"collapsed":false,"id":"074b52398902","title":"刷新邻接页"}],"collapsed":false,"id":"b85f739b5f79","title":"关键特性"},{"parent":"1712cecfa6a5","children":[{"parent":"01f760b67aa6","note":"为了协调CPU和硬盘之前的速度鸿沟,数据的操作首先是在缓冲池中进行的，然后再以一定的策略刷新的硬盘中。这就有两个问题:1.如果数据一有更新就刷新到磁盘，那数据库的效率太低了，不可取;2. 如果在还没有刷新到硬盘的过程中,数据库宕机了，数据就有可能丢失.综合上面两个原因，就需要Checkpoint机制","children":[],"id":"f8025e2bca55","title":"为什么需要Checkpoint机制"},{"parent":"01f760b67aa6","note":"白话说以一定的策略将检查点之前的数据全部刷入硬盘，而检查点之后的数据依然在缓冲池中。数据恢复直接读取检查点之前的数据，然后通过redo日志恢复当前检查点到宕机时刻的数据","children":[],"id":"c49f686cdc6e","title":"定义"},{"parent":"01f760b67aa6","children":[{"parent":"b9593eacc808","note":"当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。","children":[],"id":"190cf3679534","title":"缩短了数据库的恢复时间"},{"parent":"b9593eacc808","note":"当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。","children":[],"id":"daffd98c8941","title":"缓冲池不够用时，将脏页刷新到磁盘"},{"parent":"b9593eacc808","note":"重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置","children":[],"id":"8b15cf3c2a5e","title":"重做日志不可用时，刷新脏页"}],"id":"b9593eacc808","title":"解决了哪些问题"},{"parent":"01f760b67aa6","children":[{"parent":"73892e6fb263","children":[{"parent":"561d68e72175","note":"mysql&gt; SHOW VARIABLES LIKE &#39;innodb_fast_shutdown&#39;;","children":[],"id":"4575579ab872","title":"参数控制"},{"parent":"561d68e72175","note":"Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式","children":[],"id":"827c84bef857","title":"作用"}],"id":"561d68e72175","title":"Sharp&nbsp;Checkpoint"},{"parent":"73892e6fb263","children":[{"parent":"f8fa62530f8b","note":"但是若数据库在运行时也使用Sharp Checkpoint，那么数据库的可用性就会受到很大的影响。故在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。","children":[],"id":"ee54b37cad85","title":"作用"},{"parent":"f8fa62530f8b","children":[{"parent":"66f634721432","note":"差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘","children":[],"id":"0c68eeefba43","title":"Master&nbsp;Thread&nbsp;Checkpoint"},{"parent":"66f634721432","note":"InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量","children":[],"id":"dcae85d28673","title":"FLUSH_LRU_LIST&nbsp;Checkpoint"},{"parent":"66f634721432","note":"指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘","children":[],"id":"1b1d908f34a2","title":"Async/Sync&nbsp;Flush&nbsp;Checkpoint"},{"parent":"66f634721432","note":"即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页。其可由参数innodb_max_dirty_pages_pct控制","children":[],"id":"0811aa16696d","title":"Dirty&nbsp;Page&nbsp;too&nbsp;much&nbsp;Checkpoint"}],"id":"66f634721432","title":"发生的情况"}],"id":"f8fa62530f8b","title":"Fuzzy&nbsp;Checkpoint"}],"id":"73892e6fb263","title":"种类"}],"collapsed":true,"id":"01f760b67aa6","title":"Innodb&nbsp;Checkpoint机制"}],"collapsed":false,"id":"1712cecfa6a5","title":"InnoDB存储引擎"},{"parent":"f9a71ca6f472","children":[{"parent":"b568677aa544","children":[{"parent":"d938f73ad48f","note":"以一定格式记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。然而，若操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。","children":[],"id":"e4cecfd98a79","title":"定义"},{"parent":"d938f73ad48f","children":[{"parent":"aa45343cf970","note":"某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。","children":[],"id":"3816079b6065","title":"恢复"},{"parent":"aa45343cf970","note":"其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般称为master或primary）进行实时同步。","children":[],"id":"e9a2b1476aa1","title":"复制"},{"parent":"aa45343cf970","note":"用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击","children":[],"id":"670327b8a560","title":"审计"}],"id":"aa45343cf970","title":"作用"},{"parent":"d938f73ad48f","children":[{"parent":"105805b3d940","note":"mysql&gt; show variables like &#39;datadir&#39;;\n+---------------+-----------------+\n| Variable_name | Value           |\n+---------------+-----------------+\n| datadir       | /var/lib/mysql/ |\n+---------------+-----------------+\n","children":[],"id":"b772048409d2","title":"路径"},{"parent":"105805b3d940","note":"//二进制文件默认没有开启:\nmysql&gt; show variables like &#39;%bin%&#39;;\n| log_bin                                    | OFF                  |\n| log_bin_basename                           |                      |\n| log_bin_index                              |                      |\n\n//配置文件加入配置项\n[mysqld]\nlog_bin=/var/log/mysql/binlog.log\nserver-id=1        //这里需要注意\n\n//保存 关闭配置文件 重启mysql\nservice mysql restart\n\n//重启登录mysql查看binlog信息\nmysql&gt; show variables like &#39;%bin%&#39;;\n| log_bin                                    | ON                          |\n| log_bin_basename                           | /var/log/mysql/binlog       |\n| log_bin_index                              | /var/log/mysql/binlog.index |\n————————————————","children":[],"id":"e3eea48b1df5","title":"配置流程"}],"id":"105805b3d940","title":"配置"},{"parent":"d938f73ad48f","children":[{"parent":"a9dfeca11bcd","note":"mysql&gt; show variables like &#39;%bin%&#39;;","children":[],"id":"61b84ac1a4c4","title":"相关参数"},{"parent":"a9dfeca11bcd","note":"mysql&gt; show master status;\n\nmysql&gt; SHOW BINLOG EVENTS IN &#39;binlog.000002&#39;;","children":[],"id":"b29afc8c0311","title":"查看二进制日志状态"},{"parent":"a9dfeca11bcd","note":"root@ubuntu:/var/log/mysql# mysqlbinlog  -vv --start-position=1094 binlog.000002","children":[],"id":"b8cb85706979","title":"mysqlbinglog查看"}],"id":"a9dfeca11bcd","title":"查看"},{"parent":"d938f73ad48f","children":[{"parent":"221cbd920a8f","note":"虽影响性能,但十分有限,开启二进制日志会使性能下降1%","children":[],"id":"f8f03fbffebb","title":"影响性能"},{"parent":"221cbd920a8f","note":"binlog_format参数设置为ROW，会加大二进制文件的大小。每次执行相关的语句，会占用用磁盘空间","children":[],"id":"64d3a89b086b","title":"占用磁盘空间"}],"id":"221cbd920a8f","title":"弊端"}],"collapsed":false,"id":"d938f73ad48f","title":"二进制日志"},{"parent":"b568677aa544","children":[{"parent":"49670cc3738a","note":"将时间大于一定阈值的sql语句记录在某一个文件中，这个文件就是慢查询日志","children":[],"id":"9aac82d20457","title":"定义"},{"parent":"49670cc3738a","children":[{"parent":"0c2d362dc153","note":"//开启慢查询日志\nmysql&gt; set global slow_query_log=ON;\n\nmysql&gt; show variables like &#39;slow_query%&#39;;","children":[],"id":"f14416320b0d","title":"开启"},{"parent":"0c2d362dc153","note":"//设置sql语句超时时间\nmysql&gt; show variables like &#39;long_query_time&#39;;\nmysql&gt; set session long_query_time=1;\n\nmysql&gt; set global long_query_time=1;\nmysql&gt; show variables like &#39;long_query_time&#39;;\n\n\nmysql&gt; select @@global.long_query_time;\n\nmysql&gt; select @@session.long_query_time;","children":[],"id":"c87729c3dbf0","title":"设置sql语句超时时间"},{"parent":"0c2d362dc153","note":"//开启未使用索引查询的sql语句\nmysql&gt; set global log_queries_not_using_indexes=ON;\n\nmysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;\n\n//每分钟允许记录到slow log的且未使用索引的SQL语句次数:0 无限制\nmysql&gt; show variables like &#39;log_throttle_queries_not_using_indexes&#39;;","children":[],"id":"5e61e4980a29","title":"开启未使用索引查询的sql语句"}],"id":"0c2d362dc153","title":"配置"},{"parent":"49670cc3738a","children":[{"parent":"3e41f92dbcba","note":"//mysql.slow_log 表信息\n\nmysql&gt; SHOW CREATE TABLE mysql.slow_log;","children":[],"id":"4cc79fd8893f","title":"查看"},{"parent":"3e41f92dbcba","note":"mysql&gt; SHOW VARIABLES LIKE&#39;log_output&#39;;\n\n\nmysql&gt; SET GLOBAL log_output=&#39;TABLE&#39;;\n\n\nmysql&gt; SHOW VARIABLES LIKE&#39;log_output&#39;;\n","children":[],"id":"9ce03b9885cb","title":"将慢查询输出格式由文件转化为表"},{"parent":"3e41f92dbcba","note":" 将mysql.slow_log表存储引擎由CSV修改为MyISAM,并在start_time列上添加索引以进一步提高在大数据下查询的效率。不能忽视的是，将slow_log表的存储引擎更改为MyISAM后，还是会对数据库造成额外的开销。不过好在很多关于慢查询的参数都是动态的，用户可以方便地在线进行设置或修改。","children":[],"id":"2d5d80cfbac9","title":"提高在大数据下查询效率"}],"id":"3e41f92dbcba","title":"慢查询日志表:slow_log"}],"collapsed":false,"id":"49670cc3738a","title":"慢查询日志"},{"parent":"b568677aa544","children":[{"parent":"691772da89b4","note":"InnoDB产生的日志不可能实时刷新到磁盘中，这样效率太差，所以都时先放入内存的缓冲区中，然后以一定的规则刷新到磁盘中。这个缓冲buffer就是重做日志缓冲","children":[],"id":"eaf4b7c81bda","title":"重做日志缓冲"},{"parent":"691772da89b4","note":"在InnoDB数据目录下存有ib_logfile0和ib_logfile1,这2个文件就是重做日志文件,记录了InnoDB存储引擎的事务日志，记录了每个页更改的物理情况","children":[],"id":"1ed354bcf163","title":"定义"},{"parent":"691772da89b4","note":"当实例或者介质失效时，InnoDB存储引擎会根据重做日志恢复到实例或者介质失效前的那一刻状态","children":[],"id":"23d5021ed6a1","title":"作用"},{"parent":"691772da89b4","note":"mysql&gt; SHOW VARIABLES LIKE&#39;innodb%log%&#39;;","children":[{"parent":"37eb436377ae","note":"重做日志文件大小","children":[],"id":"6d8a335d0f00","title":"innodb_log_file_size"},{"parent":"37eb436377ae","note":"指定了日志文件组中，重做日志文件的数量,默认为2","children":[],"id":"f9e96f0cb7c2","title":"innodb_log_files_in_group"},{"parent":"37eb436377ae","note":"指定了日志镜像文件组的数量，默认为1,表示只有一个日志文件组，没有镜像。若磁盘本身已经做了高可用的方案，如磁盘阵列，那么可以不开启重做日志镜像的功能","children":[],"id":"21a5e1e2bf56","title":"innodb_mirrored_log_groups"},{"parent":"37eb436377ae","note":"指定了日志文件组所在的目录","children":[],"id":"31bc2790750d","title":"innodb_log_group_home_dir"}],"id":"37eb436377ae","title":"文件属性"},{"parent":"691772da89b4","children":[{"parent":"1f7f379bd684","note":"在恢复时可能需要很长的时间","children":[],"id":"7bf7f3dae557","title":"太大"},{"parent":"1f7f379bd684","note":"可能导致一个事务的日志需要多次切换重做日志文件","children":[],"id":"04eb13ce185d","title":"太小"}],"id":"1f7f379bd684","title":"文件大小"},{"parent":"691772da89b4","children":[{"parent":"21f2dcaff33b","note":"先写入一个重做日志缓冲（redo log buffer）中，然后按照一定的条件顺序地写入日志文件。从重做日志缓冲往磁盘写入时，是按512个字节，也就是一个扇区的大小进行写入。因为扇区是写入的最小单位，因此可以保证写入必定是成功的。因此在重做日志的写入过程中不需要有doublewrite\n","children":[{"parent":"5df10aaf1e4a","children":[],"id":"502b4bd1ed4b","title":"先写入redo log buffer"},{"parent":"5df10aaf1e4a","children":[],"id":"a73d69e494c4","title":"按512个字节依次写入磁盘"}],"id":"5df10aaf1e4a","title":"写入流程"},{"parent":"21f2dcaff33b","children":[{"parent":"60bcc687793f","note":"主线程(master thread)中每秒会将重做日志缓冲写入磁盘的重做日志文件中，不论事务是否已经提交","children":[],"id":"113053d15217","title":"主线程"},{"parent":"60bcc687793f","note":"mysql&gt; show variables like &#39;innodb_flush_log_at_trx_commit&#39;;","children":[{"parent":"15abb288a83d","note":"代表当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。","children":[],"id":"4b01710a0ced","title":"0"},{"parent":"15abb288a83d","note":"表示在执行commit时将重做日志缓冲同步写到磁盘，即伴有fsync的调用。为了保证事务的ACID中的持久性，必须将innodb_flush_log_at_trx_commit设置为1","children":[],"id":"84108d4a269a","title":"1"},{"parent":"15abb288a83d","note":"表示将重做日志异步写到磁盘，即写到文件系统的缓存中。因此不能完全保证在执行commit时肯定会写入重做日志文件，只是有这个动作发生。","children":[],"id":"083878732678","title":"2"}],"id":"15abb288a83d","title":"innodb_flush_log_at_trx_commit"}],"id":"60bcc687793f","title":"写入磁盘条件"}],"id":"21f2dcaff33b","title":"写入磁盘"},{"parent":"691772da89b4","note":"log group为重做日志组，其中有多个重做日志文件。","children":[],"id":"cfc207983fb1","title":"文件组"},{"parent":"691772da89b4","children":[{"parent":"c8f028852698","note":"InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志，如二进制日志，要快很多","children":[],"id":"40c52048451d","title":"原理"},{"parent":"c8f028852698","note":"由于checkpoint表示已经刷新到磁盘页上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。对于图7-12中的例子，当数据库在checkpoint的LSN为10 000时发生宕机，恢复操作仅恢复LSN 10 000～13 000范围内的日志。","image":{"w":900,"h":567.9144385026738,"url":"http://cdn.processon.com/62790a88f346fb18e7ca182d?e=1652103320&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:YetzaHQ-tLFAq5wmAeq0Vj-7Rog=","direction":"up"},"children":[],"id":"970f48d6302c","title":"恢复流程"}],"id":"c8f028852698","title":"恢复机制"},{"parent":"691772da89b4","note":"InnoDB存储引擎的重做日志是物理日志，因此其恢复速度较之二进制日志恢复快得多。例如对于INSERT操作，其记录的是每个页上的变化。记录的是页的物理修改操作","children":[],"id":"eb8cf1c76723","title":"记录的内容"},{"parent":"691772da89b4","children":[{"parent":"60c03f72dded","children":[{"parent":"b99222a4ad67","note":"其用来进行POINT-IN-TIME（PIT）的恢复及主从复制（Replication）环境的建立","children":[],"id":"d8fec0dc0558","title":"二进制日志"},{"parent":"b99222a4ad67","note":"在InnoDB数据目录下存有ib_logfile0和ib_logfile1,这2个文件就是重做日志文件,记录了InnoDB存储引擎的事务日志，记录了每个页更改的物理情况","children":[],"id":"403538356b8a","title":"重做日志"}],"id":"b99222a4ad67","title":"定义"},{"parent":"60c03f72dded","note":"重做日志是在InnoDB存储引擎层产生，而二进制日志是在MySQL数据库的上层产生的，并且二进制日志不仅仅针对于InnoDB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。","children":[{"parent":"ddf048137198","note":"MySQL数据库的上层产生","children":[],"id":"2fc4896aefe1","title":"二进制日志"},{"parent":"ddf048137198","note":"InnoDB存储引擎层产生","children":[],"id":"bbc57475069b","title":"重做日志"}],"id":"ddf048137198","title":"产生方式"},{"parent":"60c03f72dded","note":"两种日志记录的内容形式不同。MySQL数据库上层的二进制日志是一种逻辑日志，其记录的是对应的SQL语句。而InnoDB存储引擎层面的重做日志是物理格式日志，其记录的是对于每个页的修改","children":[{"parent":"4748d6efaec5","note":"逻辑日志","children":[],"id":"d90caa6b045b","title":"二进制日志"},{"parent":"4748d6efaec5","note":"物理日志","children":[],"id":"cd9c4c8a1529","title":"重做日志"}],"id":"4748d6efaec5","title":"记录内容"},{"parent":"60c03f72dded","note":"二进制日志只在事务提交完成后进行一次写入。而InnoDB存储引擎的重做日志在事务进行中不断地被写入，这表现为日志并不是随事务提交的顺序进行写入的。","children":[{"parent":"703ae3e7d24d","note":"事务提交一次性写入","children":[],"id":"16bc8daf6acd","title":"二进制日志"},{"parent":"703ae3e7d24d","note":"随着事务进行,不断写入","children":[],"id":"92f3708378b5","title":"重做日志"}],"id":"703ae3e7d24d","title":"写入磁盘的时间点"}],"id":"60c03f72dded","title":"重做日志(redo&nbsp;log)&nbsp;VS&nbsp;二进制日志(binlog)"}],"collapsed":false,"id":"691772da89b4","title":"重做日志文件"},{"parent":"b568677aa544","children":[{"parent":"af08908652b1","note":"记录了事务的运行日志,用来进行事务回滚的所需要的文件","children":[],"id":"8ae7a98412a2","title":"定义"},{"parent":"af08908652b1","children":[{"parent":"757f8ddf25ed","children":[],"id":"b20cad435515","title":"对事务进行回滚"},{"parent":"757f8ddf25ed","note":"当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo log读取之前的行版本信息，以此实现一致性非锁定读取。","children":[],"id":"3906839c7e88","title":"MVCC控制"},{"parent":"757f8ddf25ed","image":{"w":816,"h":699,"url":"http://cdn.processon.com/628636f8e401fd55ba349c50?e=1652966664&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0mM7vYuPAZxG5qOYHlsC0h4LALo=","direction":"up"},"children":[],"id":"2a36ee23b8f5","title":""}],"id":"757f8ddf25ed","title":"作用"},{"parent":"af08908652b1","children":[{"parent":"00b2ad87d3e5","children":[],"id":"039befce4a6e","title":"共享表空间内的undo log段"}],"id":"00b2ad87d3e5","title":"存放位置"},{"parent":"af08908652b1","children":[{"parent":"32fdcf367b42","note":"undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。","children":[],"id":"d54d62adbceb","title":"undo log是逻辑日志"},{"parent":"32fdcf367b42","note":"undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护","children":[],"id":"5d40565e5dd7","title":"undo log会产生redo log"}],"id":"32fdcf367b42","title":"注意事项"},{"parent":"af08908652b1","children":[{"parent":"080cf299ae53","note":"mysql&gt; show variables like &#39;innodb_undo%&#39;;\nmysql&gt; show variables like &#39;datadir%&#39;;","children":[],"id":"daa9df651d68","title":"undo&nbsp;设置"},{"parent":"080cf299ae53","note":"InnoDB存储引擎有rollback segment，每个回滚段种记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。","children":[],"id":"a3aedcbba323","title":"段管理"},{"parent":"080cf299ae53","children":[{"parent":"50ded40265c3","note":"undo log segment段中进行undo页的申请.分配和申请需要产生redo log","children":[],"id":"59759e42ada1","title":"undo页申请"},{"parent":"50ded40265c3","note":"1. 将undo log放入列表中，以供之后的purge操作\n2. 判断undo log所在的页是否可以重用，若可以分配给下个事务使用","children":[],"id":"0f84cfcd72a6","title":"事务提交时"},{"parent":"50ded40265c3","note":"事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。","children":[],"id":"df46df7fcea5","title":"事务提交后"}],"id":"50ded40265c3","title":"申请与写入"},{"parent":"080cf299ae53","children":[{"parent":"0fbe2fd0d58f","note":"若为每一个事务分配一个单独的undo页会非常浪费存储空间，特别是对于OLTP的应用类型。因为在事务提交时，可能并不能马上释放页。假设某应用的删除和更新操作的TPS（transaction per second）为1000，为每个事务分配一个undo页，那么一分钟就需要1000*60个页，大约需要的存储空间为1GB。若每秒的purge页的数量为20，这样的设计对磁盘空间有着相当高的要求。因此，在InnoDB存储引擎的设计中对undo页可以进行重用。","children":[],"id":"a89a23375656","title":"作用:减少占用磁盘空间"},{"parent":"0fbe2fd0d58f","note":"当事务提交时，首先将undo log放入链表中，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面","children":[],"id":"b9c55fe47f85","title":"重用算法"}],"id":"0fbe2fd0d58f","title":"undo log重用"},{"parent":"080cf299ae53","children":[{"parent":"af20876bbee0","note":"//每次purge操作需要清理的undo page数量\nmysql&gt; show variables like &#39;innodb_purge_batch_size&#39;;\n\n//用来控制history list的长度，若长度大于该参数时，其会“延缓”DML的操作。该参数默认值为0，表示不对history list做任何限制。\nmysql&gt; show variables like &#39;innodb_max_purge_lag&#39;;\n\n//当innodb_max_purge_lag 大于0时，就会延缓DML的操作，其延缓的算法为：delay=（（length(history_list)-innodb_max_purge_lag）*10)-5\n\n//来控制delay的最大毫秒数。也就是当上述计算得到的delay值大于该参数时，将delay设置为innodb_max_purge_lag_delay，避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。\nmysql&gt; show variables like &#39;innodb_max_purge_lag_delay&#39;;","children":[],"id":"2b6e2dae3608","title":"相关设置"},{"parent":"af20876bbee0","note":"InnoDB存储引擎这种通过purge线程先从history list中找undo page，然后再从undo page中找undo log","children":[],"id":"8124941a7530","title":"算法概述"},{"parent":"af20876bbee0","image":{"w":900,"h":534.8531684698609,"url":"http://cdn.processon.com/62863d787d9c085aacc3de1d?e=1652968328&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:d3Y92x6l8pGiarC2fJ-7jAVPsaU=","direction":"up"},"children":[],"id":"338df9b24239","title":""},{"parent":"af20876bbee0","note":"避免大量的随机读取操作，从而提高purge的效率","children":[],"id":"0e08393f0822","title":"优点"}],"id":"af20876bbee0","title":"undo log回收"}],"id":"080cf299ae53","title":"存储管理"},{"parent":"af08908652b1","children":[{"parent":"92c3ba5f6647","children":[{"parent":"73fe5b5a34d1","note":"是指在insert操作中产生的undo log","children":[],"id":"7a40357bcc72","title":"定义"},{"parent":"73fe5b5a34d1","note":"因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作","children":[],"id":"234dbedf806a","title":"回收"}],"id":"73fe5b5a34d1","title":"insert&nbsp;undo&nbsp;log"},{"parent":"92c3ba5f6647","children":[{"parent":"75121b2e0000","note":"记录的是对delete和update操作产生的undo log","children":[],"id":"c7eef136a535","title":"定义"},{"parent":"75121b2e0000","note":"该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。","children":[],"id":"b0f5b0251cfd","title":"回收"}],"id":"75121b2e0000","title":"update undo&nbsp;log"}],"id":"92c3ba5f6647","title":"undo log分类"}],"collapsed":false,"id":"af08908652b1","title":"undo log"}],"id":"b568677aa544","title":"日志"}],"collapsed":false,"id":"f9a71ca6f472","title":"基础"}],"root":true,"theme":"delicate_caihong","id":"root","title":"mysql","version":27,"structure":"mind_free"}},"meta":{"exportTime":"2022-08-27 15:18:42","member":"616fddd81efad42eb5ecab9b","diagramInfo":{"creator":"616fddd81efad42eb5ecab9b","created":"2022-03-12 16:13:19","modified":"2022-08-25 21:03:31","title":"mysql","category":"mind_free"},"id":"622c561f7d9c08076d00f21b","type":"ProcessOn Schema File","version":"1.0"}}