{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"40a0e4c61121","children":[],"id":"d06d8b66754a","title":"redis cluster 部署和配置"},{"parent":"40a0e4c61121","children":[],"id":"3dc80edd106b","title":"redis slot 分配算法:&nbsp;HASH_SLOT&nbsp;=&nbsp;CRC16(key)&nbsp;mod&nbsp;16384"},{"parent":"40a0e4c61121","children":[{"parent":"ec06f8ddba4b","children":[],"id":"203358f005c1","title":"定义:哈希标签是确保两个键都在同一个哈希槽里的一种方式"},{"parent":"ec06f8ddba4b","children":[{"parent":"e212b05c49e0","children":[{"parent":"9a297a02da07","children":[],"id":"87fff53358f2","title":"只有{&nbsp;和&nbsp;}&nbsp;之间的字符串会被用来做哈希以获取哈希槽"}],"id":"9a297a02da07","title":"只有一对{…}"},{"parent":"e212b05c49e0","children":[],"id":"1fba30f5e0c6","title":"多个&nbsp;{&nbsp;或&nbsp;}"}],"id":"e212b05c49e0","title":"规则"}],"id":"ec06f8ddba4b","title":"Key&nbsp;Hash&nbsp;Tags模型"},{"parent":"40a0e4c61121","children":[{"parent":"498e43e8c88f","children":[{"parent":"e32c7c8a7f05","children":[],"id":"1e8b596ecf85","title":"命令模式: GET&nbsp;x<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -MOVED&nbsp;3999&nbsp;127.0.0.1:6381"},{"parent":"e32c7c8a7f05","children":[],"id":"14fe2d66e351","title":"特点: 客户端收到&nbsp;MOVED&nbsp;指令后，要立即纠正本地的槽位映射表。后续所有&nbsp;key&nbsp;将使用新的槽位映射表"},{"parent":"e32c7c8a7f05","children":[],"id":"ba6bb472775b","title":"发生条件: 集群哈希槽被重新配置(集群主节点增加或者减少等等情况导致)"}],"id":"e32c7c8a7f05","title":"MOVE"},{"parent":"498e43e8c88f","children":[{"parent":"e91f820b94ce","children":[],"id":"1f0ff180371f","title":"命令模式: GET&nbsp;x&nbsp;//向A节点发送<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -ASK&nbsp;B&nbsp;//重定向到B节点<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ASKING&nbsp;//向B节点请求访问带有IMPORTING状态的槽的查询<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GET&nbsp;x&nbsp;//向B节点正式请求数据"},{"parent":"e91f820b94ce","children":[{"parent":"bb204df5ff06","children":[],"id":"d0b42687e68d","title":"在相应的哈希槽迁移过程中,只是客户端的下一个查询发送到指定节点上去"},{"parent":"bb204df5ff06","children":[],"id":"c545c3f82156","title":"一旦相应的哈希槽迁移完毕,ASK就被换为MOVE"}],"id":"bb204df5ff06","title":"特点:"},{"parent":"e91f820b94ce","children":[],"id":"d9c43cef6922","title":"发生条件: 集群中数据对应的哈希槽正在迁移过程中(集群主节点增加或者减少等等情况导致)"}],"id":"e91f820b94ce","title":"ASK"}],"id":"498e43e8c88f","title":"重定向"},{"parent":"40a0e4c61121","children":[{"parent":"4b85daed9556","children":[],"id":"88d65ce1b115","title":"Gossip协议: Redis集群节点采用Gossip协议来广播自己的状态以及自己对整个集群认知的改变"},{"parent":"4b85daed9556","children":[{"parent":"61d0c0fd1390","children":[],"id":"fa9e77584950","title":"定义:可能失效(主观失效)"},{"parent":"61d0c0fd1390","children":[{"parent":"7e81b3ff4fe7","children":[],"id":"c4429ed90dfc","title":"假设节点A先标记节点B为PFAIL状态"},{"parent":"7e81b3ff4fe7","children":[],"id":"76448284da26","title":"节点A通过Gossip协议接收到majority master在指定时间(NODE_TIMEOUT&nbsp;*&nbsp;FAIL_REPORT_VALIDITY_MULT)标记B的状态为PFAIL或者FAIL"},{"parent":"7e81b3ff4fe7","children":[],"id":"8a5b6eefae0c","title":"节点A将B标记为FAIL,并且通过Gossip协议通知到整个集群,强制other masters标记节点B为FAIL"}],"id":"7e81b3ff4fe7","title":"PFAIL -&gt; FAIL条件"}],"id":"61d0c0fd1390","title":"PFAIL(possibly fail)"},{"parent":"4b85daed9556","children":[{"parent":"2a016e259f42","children":[{"parent":"2c59b5896b60","children":[],"id":"d89d542b54e9","title":"通过Gossip协议广播到集群其他主节点,强制主节点标记此节点为FAIL状态"},{"parent":"2c59b5896b60","children":[],"id":"fdad17fab93c","title":"如果是master为FAIL状态,接下来该mater下所有replicas进行选举提升为新的master"}],"id":"2c59b5896b60","title":"相当于客观失效"}],"id":"2a016e259f42","title":"FAIL"}],"id":"4b85daed9556","title":"集群失效检测(failure detection)"},{"parent":"40a0e4c61121","children":[{"parent":"7c24e05453a6","children":[],"collapsed":false,"id":"629db2bf8917","title":"特点:&nbsp;从节点自己发出promote请求,masters&nbsp;response&nbsp;vote"},{"parent":"7c24e05453a6","children":[{"parent":"f8057532a21d","children":[],"id":"94bb01294c84","title":"master is in FAIL"},{"parent":"f8057532a21d","children":[],"id":"871620e4f32d","title":"master的哈希槽数量不为零"},{"parent":"f8057532a21d","children":[],"id":"6b57ddcefffb","title":"replica与master的断线不超过给定时间(保证replica的数据较新)"}],"id":"f8057532a21d","title":"发起选举条件"},{"parent":"7c24e05453a6","children":[{"parent":"fc959d315751","children":[],"id":"101abab6f47d","title":"将自身currentEpoch + 1"},{"parent":"fc959d315751","children":[],"id":"27b26228174e","title":"向所有的masters发送投票请求, if epoch of response &lt; currentepoch of the replica，ingore the vote"},{"parent":"fc959d315751","children":[],"id":"0a5fe66d712f","title":"获得majority masters votes，开始用&nbsp;ping&nbsp;和&nbsp;pong&nbsp;数据包向其他节点宣布自己已经是主节点，并提供它负责的哈希槽"},{"parent":"fc959d315751","children":[],"id":"13f33c1dfce8","title":"将自身的configEpoch 设置为当前的currentEpoch"},{"parent":"fc959d315751","children":[],"id":"522600474397","title":"其他旧master的replica将同步新的master的数据"}],"id":"fc959d315751","title":"步骤"}],"id":"7c24e05453a6","title":"从节点选举提升"},{"parent":"40a0e4c61121","children":[{"parent":"6264aa9c7dae","children":[{"parent":"829ef15e9653","children":[],"id":"6f6a801f1110","title":"epoch of request &lt; lastVoteEpoch of master,拒绝投票"},{"parent":"829ef15e9653","children":[],"id":"64241b711b90","title":"投票, lastVoteEpoch = epoch of request"}],"id":"829ef15e9653","title":"在一个给定的时段(epoch)里，一个主节点只能投一次票，并且拒绝给以前时段投票"},{"parent":"6264aa9c7dae","children":[{"parent":"9ce124a7e3cb","children":[],"id":"725f62253558","title":"主节点的回应总是带着和认证请求一致的currentEpoch"},{"parent":"9ce124a7e3cb","children":[],"id":"efc92f724c3a","title":"如果同一个从节点在增加currentEpoch后再次请求投票，那么保证一个来自于主节点的、旧的延迟回复不会被新一轮选举接受"}],"id":"9ce124a7e3cb","title":"currentEpoch of request &lt; currentEpoch of master, ignore the vote"}],"id":"6264aa9c7dae","title":"主节点回复从节点投票规则"},{"parent":"40a0e4c61121","children":[{"parent":"998573799adb","children":[],"id":"721448c595db","title":"作用:&nbsp;提高集群系统的可用性"},{"parent":"998573799adb","children":[],"id":"a938bb40d159","title":"算法举例:&nbsp;如果有10个主节点，它们各有1个从节点，另外还有2个主节点，它们各有5个从节点。当发生故障转移时,会尝试迁移的从节点是在那2个拥有5个从节点的主节点中的所有从节点里，节点&nbsp;ID&nbsp;最小的那个。"}],"id":"998573799adb","title":"备份迁移算法"}],"collapsed":true,"id":"40a0e4c61121","title":"redis集群"},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"85191ec45396","children":[{"parent":"6ffa24fc9cad","children":[{"parent":"471f22e6a56e","children":[],"id":"91aabcab4cea","title":"算法流程"},{"parent":"471f22e6a56e","children":[],"id":"b1d5c903d7b6","title":"注意事项"},{"parent":"471f22e6a56e","children":[],"id":"49f38ad159b8","title":"安全or不安全"}],"id":"471f22e6a56e","title":"redlock"},{"parent":"6ffa24fc9cad","children":[{"parent":"8e823a8dca49","children":[],"id":"31550b139c42","title":"redlock-cpp"},{"parent":"8e823a8dca49","children":[],"id":"a112a5373d80","title":"使用场景"}],"id":"8e823a8dca49","title":"分布式锁使用"}],"id":"6ffa24fc9cad","title":"redis分布式锁"},{"parent":"85191ec45396","children":[{"parent":"bb55457e586f","children":[{"parent":"555f11ebfbce","children":[],"id":"21eaf4461f19","title":"zset:有序列表"}],"id":"555f11ebfbce","title":"实现"},{"parent":"bb55457e586f","children":[],"id":"4cf13637119e","title":"使用场景"}],"id":"bb55457e586f","title":"延时队列"},{"parent":"85191ec45396","children":[{"parent":"cb19411b0fbf","children":[],"id":"a948bc659203","title":"定义:属于一种空间效率型的数据结构,判断数据是否在其中,空间占用小"},{"parent":"cb19411b0fbf","children":[],"id":"a413345be270","title":"算法原理:多个无偏差的hash,每个hash算出来一个在容器中的bit,然后多个bit标记一个原数据"},{"parent":"cb19411b0fbf","children":[],"id":"7b28b3918454","title":"特点:判断不存在的,肯定不存在"},{"parent":"cb19411b0fbf","children":[{"parent":"57844918745f","children":[],"id":"0932361eed2b","title":"去重"},{"parent":"57844918745f","children":[],"id":"579c7009c668","title":"垃圾(邮件)过滤"},{"parent":"57844918745f","children":[],"id":"702c89154a38","title":"推荐系统"}],"id":"57844918745f","title":"使用场景"},{"parent":"cb19411b0fbf","children":[],"id":"9e8a7ac3815f","title":"相关公式:大概数据规模n,容器大小l(bit),hash函数个数k,误差率f(以及超过数据规模n的f的变化趋势)"}],"id":"cb19411b0fbf","title":"布隆过滤器"},{"parent":"85191ec45396","children":[{"parent":"df24f593dc5f","children":[{"parent":"e3c911d08460","children":[{"parent":"0aceeedaac79","children":[],"id":"70bb5b839f43","title":"优势:实现简单"},{"parent":"0aceeedaac79","children":[],"id":"4a952f92fb14","title":"劣势:如果行为量大且统计时间长,使用空间大"}],"id":"0aceeedaac79","title":"简单限流算法:使用zset结构 score使用时间来实现"},{"parent":"e3c911d08460","children":[{"parent":"c17b3dd64691","children":[],"id":"aaee7c15a4bb","title":"优势:占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量"},{"parent":"c17b3dd64691","children":[],"id":"80db4cf77d74","title":"劣势:实现稍微复杂些"}],"id":"c17b3dd64691","title":"漏斗限流算法(令牌桶算法)"}],"id":"e3c911d08460","title":"单机限流算法"},{"parent":"df24f593dc5f","children":[{"parent":"22dc35defcc5","children":[{"parent":"52a0321d0ce1","children":[],"id":"b13f997977f0","title":"特点:也使用了漏斗算法，并提供了原子的限流指令"},{"parent":"52a0321d0ce1","children":[],"id":"ceb1a889e733","title":"模块使用"}],"id":"52a0321d0ce1","title":"Redis-Cell模块"}],"id":"22dc35defcc5","title":"分布式漏斗限流算法(分布式令牌桶算法)"}],"id":"df24f593dc5f","title":"限流算法"},{"parent":"85191ec45396","children":[{"parent":"f90738fd487f","children":[],"id":"dc4209b64234","title":"算法流程"},{"parent":"f90738fd487f","children":[{"parent":"251a7f73cfd5","children":[],"id":"2ead5378bb09","title":"优势:当然是处理效率高,定位每个位置元素的时间复杂度O(logN)"},{"parent":"251a7f73cfd5","children":[{"parent":"5c4624de193b","children":[],"id":"ade032c2107f","title":"处理突变:另外获取位置点周围的8个区域点信息"}],"id":"5c4624de193b","title":"缺点:相邻区块的点会有突变现象"}],"id":"251a7f73cfd5","title":"特点"},{"parent":"f90738fd487f","children":[{"parent":"6e57afea420e","children":[],"id":"085ee76359d8","title":"主要用于获取附近的\"人\"相似功能"}],"id":"6e57afea420e","title":"使用场景"},{"parent":"f90738fd487f","children":[{"parent":"eb05d22d2bcc","children":[],"id":"6f86f207333a","title":"相关命令"},{"parent":"eb05d22d2bcc","children":[{"parent":"00dd5490daab","note":"","children":[],"id":"e51448d9f502","title":"建议Geo&nbsp;的数据使用单独的&nbsp;Redis&nbsp;实例部署,不使用集群环境"},{"parent":"00dd5490daab","children":[],"id":"fbd371f80fc2","title":"可以考虑对Geo数据进行拆分，按国家拆分、按省拆分，按市拆分"}],"id":"00dd5490daab","title":"使用注意"}],"id":"eb05d22d2bcc","title":"Redis&nbsp;GeoHash模块使用"}],"id":"f90738fd487f","title":"GeoHash算法"}],"collapsed":true,"id":"85191ec45396","title":"redis实用"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"52fb40237da0","children":[{"parent":"0f634c41b956","children":[],"id":"69a8c4211eca","title":"定义: redis和数据库中都不存在此数据,但是外部确访问它,导致会透过redis访问数据库<br>"},{"parent":"0f634c41b956","children":[{"parent":"922db40f567a","children":[],"id":"2f483fbf4f4f","title":"提升数据库负载"},{"parent":"922db40f567a","children":[],"id":"52911bb7fab5","title":"没有数据返回也造成了网络和计算资源的浪费"}],"id":"922db40f567a","title":"危害<br>"},{"parent":"0f634c41b956","children":[{"parent":"0d5a3ae7b7ad","children":[],"id":"55d2296e6754","title":"接口层对参数进行校验,屏蔽非法访问"},{"parent":"0d5a3ae7b7ad","children":[],"id":"0b48d8cec33e","title":"利用redis布隆过滤器判断底层数据库key是否存在,屏蔽不存在key的数据访问"},{"parent":"0d5a3ae7b7ad","children":[],"id":"e47548e90b26","title":"检测到非法访问,也可以采用封ip 封mac的方式"}],"id":"0d5a3ae7b7ad","title":"避免"}],"collapsed":false,"id":"0f634c41b956","title":"缓存穿透"},{"parent":"52fb40237da0","children":[{"parent":"a8828fbc7ab7","children":[],"id":"736fe3f084fd","title":"定义:热点key从缓存中失效(单个),导致请求穿过redis,直接下层到数据库,增加数据库负载.(redis中不存在此数据,但是数据库中存在此数据)"},{"parent":"a8828fbc7ab7","children":[],"id":"cd005a8ab936","title":"危害:同缓存穿透"},{"parent":"a8828fbc7ab7","children":[{"parent":"8a1d97477b85","children":[],"id":"f73eaa09cd2a","title":"定期延长热点key的过期时间或者设置永不过期<br>"},{"parent":"8a1d97477b85","children":[],"id":"1759f5cd3a74","title":"当热点key从缓存中失效时,利用redis的lua脚本原子操作机制,使只有一个请求透过redis,从数据库中访问数据并加载到redis中，之后其他请求从Redis中获取数据"}],"id":"8a1d97477b85","title":"避免"}],"collapsed":false,"id":"a8828fbc7ab7","title":"缓存击穿"},{"parent":"52fb40237da0","children":[{"parent":"f1e16301f712","children":[],"id":"f9666282dbaa","title":"定义: redis中大量的热点数据几乎同时失效,大量的并发请求直接打到数据库层，数据库压力大增"},{"parent":"f1e16301f712","children":[],"id":"bbe8ca96e8aa","title":"危害:可以说后果非常严重,非常可能导致数据库崩溃,进而导致redis崩溃,最后服务大面积崩溃.即使重启相应服务也无法避免崩溃后果"},{"parent":"f1e16301f712","children":[{"parent":"82a60a961161","children":[],"id":"11b19da079e8","title":"在可接受的时间范围内随机key的过期时间,分散因key集中过期导致的数据库层压力"},{"parent":"82a60a961161","children":[],"id":"c519710ab7cc","title":"延长热点key的过期时间或者设置永不过期"},{"parent":"82a60a961161","children":[],"id":"24943fc0a12a","title":"对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来<br>"}],"id":"82a60a961161","title":"避免"}],"collapsed":false,"id":"f1e16301f712","title":"缓存雪崩"},{"parent":"52fb40237da0","children":[{"parent":"ad1cd74691b9","children":[],"id":"f55a03fc0b23","title":"定义:在上线前,现将数据库中的热点数据加载到redis中,然后上线时开放对外请求<br>"},{"parent":"ad1cd74691b9","children":[{"parent":"c5a28faf722b","children":[],"id":"f3eda8aaef65","title":"上线时进行批任务处理"},{"parent":"c5a28faf722b","children":[],"id":"73effb1834c5","title":"定时进行批任务处理"}],"id":"c5a28faf722b","title":"操作"}],"collapsed":false,"id":"ad1cd74691b9","title":"缓存预热"},{"parent":"52fb40237da0","children":[{"parent":"dc997068a87b","children":[],"id":"31fcfbbe4662","title":"定义:缓存服务(Redis)和数据服务(底层数据库)是相互独立且异构的系统，在更新缓存时要与数据库保持一致"},{"parent":"dc997068a87b","children":[{"parent":"9dac90f5ffa3","children":[{"parent":"32f74484960b","children":[{"parent":"c1990ef245d4","children":[],"id":"3d57cba2ab69","title":"先查缓存，缓存没有就查数据库，然后加载至缓存内"}],"id":"c1990ef245d4","title":"查询"},{"parent":"32f74484960b","children":[{"parent":"3fa858bf7ebb","children":[],"id":"1a16d59f8400","title":"先更新数据库,然后让缓存失效"},{"parent":"3fa858bf7ebb","children":[],"id":"dc86cd7320dd","title":"先失效缓存然后更新数据库"}],"id":"3fa858bf7ebb","title":"更新"}],"id":"32f74484960b","title":"Cache&nbsp;aside"},{"parent":"9dac90f5ffa3","children":[],"id":"047d6b203288","title":"Read&nbsp;through: 在查询操作中更新缓存，即当缓存失效时,缓存服务自己来加载<br>"},{"parent":"9dac90f5ffa3","children":[{"parent":"7db5948acdae","children":[],"id":"7f1c693251d9","title":"当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回"},{"parent":"7db5948acdae","children":[],"id":"05d3cab57737","title":"当有数据更新的时候, 如果命中了缓存，则更新缓存，然后由缓存自己更新数据库；"}],"id":"7db5948acdae","title":"Write&nbsp;through"},{"parent":"9dac90f5ffa3","children":[],"id":"308be30bd328","title":"Write&nbsp;behind&nbsp;caching:&nbsp;俗称write&nbsp;back，在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地定时批量更新数据库；"}],"id":"9dac90f5ffa3","title":"更新方式"},{"parent":"dc997068a87b","children":[{"parent":"30cfc31914ea","children":[],"id":"bafedfa3ed48","title":"在写请求失效缓存时设置一个1s延迟时间，然后再去更新数据库的数据，此时其他读请求仍然可以读到缓存内的数据，当数据库端更新完成后，缓存内的数据已失效，之后的读请求会将数据库端最新的数据加载至缓存内保证缓存和数据库端数据一致性；"}],"id":"30cfc31914ea","title":"推荐缓存更新方式: 先失效缓存,后更新数据库 + 延迟失效(比如key失效时间1s)<br>"}],"collapsed":false,"id":"dc997068a87b","title":"缓存更新"},{"parent":"52fb40237da0","children":[{"parent":"145abbb1fbf6","children":[],"id":"015ec67a5e45","title":"定义:当访问量剧增,影响到主服务的可用性时,通过降低次要服务的相关体验,对次要服务的相关数据进行降级处理,保护主服务的流畅可用"},{"parent":"145abbb1fbf6","children":[{"parent":"d95bb3530ec4","children":[],"id":"b409e841c713","title":"通过实时监控程序进行自动降级"},{"parent":"d95bb3530ec4","children":[],"id":"c04e77f1ce87","title":"通过配置开关进行人工降级<br>"}],"id":"d95bb3530ec4","title":"操作"}],"collapsed":false,"id":"145abbb1fbf6","title":"缓存降级"}],"collapsed":true,"id":"52fb40237da0","title":"redis企业级问题"}],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"a3b7c8685b6a","children":[],"id":"c59d69522769","title":"redis基本使用 "},{"parent":"a3b7c8685b6a","children":[{"parent":"2ebb8454e5ca","children":[],"id":"ec4f0d9dff45","title":"必要性:redis是内存型数据库,一旦断电或者宕机,数据会消失,所以需要持久化支持"},{"parent":"2ebb8454e5ca","children":[{"parent":"91fbbca9b4ba","children":[{"parent":"957e3b7cabdd","children":[{"parent":"af346089f932","children":[],"id":"b68fb73435ba","title":"一次全量数据备份"},{"parent":"af346089f932","children":[],"id":"ca4278b283bf","title":"加载速度快"},{"parent":"af346089f932","children":[],"id":"4bea5ee8bde0","title":"是内存的二进制格式,存储比较紧凑"}],"id":"af346089f932","title":"特点"},{"parent":"957e3b7cabdd","children":[],"id":"e07d14c7293a","title":"原理:利用操作系统写时复制机制"},{"parent":"957e3b7cabdd","children":[],"id":"00feb0ce8bc4","title":"过程:当执行bgsave时,逻辑主线程fork一个子进程,由于写时复制机制,子进程拥有此刻主线程的所有内存数据,然后子进程遍历写入rdb文件即可"},{"parent":"957e3b7cabdd","children":[{"parent":"133bb1d6f3f9","children":[{"parent":"b56bb24309a1","children":[],"id":"d1121c6c6734","title":"特点:同步模式,由于redis处理客户端请求是单线程,所以持久化过程会阻塞客户端的请求,直到持久化完成"},{"parent":"b56bb24309a1","children":[],"id":"cb452fd16803","title":"过程:执行命令后立刻启动持久化流程.逻辑线程将内存数据写入rdb文件即可"}],"id":"b56bb24309a1","title":"save"},{"parent":"133bb1d6f3f9","children":[{"parent":"91dc90c72ea0","children":[],"id":"44b06feab444","title":"特点:异步模式,fork子进程,不会阻塞客户端的响应"},{"parent":"91dc90c72ea0","children":[],"id":"870f24677d37","title":"过程:看上面"}],"id":"91dc90c72ea0","title":"bgsave"}],"id":"133bb1d6f3f9","title":"注意事项"},{"parent":"957e3b7cabdd","children":[],"id":"68ecb8b39b16","title":"conf配置:save&nbsp;&lt;seconds&gt;&nbsp;&lt;changes&gt;"}],"collapsed":false,"id":"957e3b7cabdd","title":"快照(rdb)"},{"parent":"91fbbca9b4ba","children":[{"parent":"0f4de7f99036","children":[],"id":"0ce4e1486c4c","title":"定义:记录redis服务器使内存数据变化的指令,并写入生成的一种文件"},{"parent":"0f4de7f99036","children":[{"parent":"6cc17febe6ae","children":[],"id":"46ddd0ef9d63","title":"是连续增量的日志备份"},{"parent":"6cc17febe6ae","children":[],"id":"40463aeed6aa","title":"记录内存数据修改的指令文本"},{"parent":"6cc17febe6ae","children":[],"id":"12985e6ee256","title":"需要定期进行aof日志瘦身,避免日志文件过大"}],"id":"6cc17febe6ae","title":"特点"},{"parent":"0f4de7f99036","children":[],"id":"b0a7777dcbb3","title":"原理:收到指令,如果是使内存数据变化的,先写入aof日志,在执行指令"},{"parent":"0f4de7f99036","children":[],"id":"8d0cf4340865","title":"AOF重放:根据AOF日志,就可以通过对一个空的Redis实例顺序执行所有的指令,也就是重放,来恢复Redis当前实例的内存数据结构的状态"},{"parent":"0f4de7f99036","children":[{"parent":"9ebcf3c2678e","children":[{"parent":"eab7e5bf6ef9","children":[],"id":"085628eb038b","title":"rewriteaof"},{"parent":"eab7e5bf6ef9","children":[{"parent":"6b0d4b4d2136","children":[],"id":"d9047aa70c30","title":"特点:fork子进程的方式重写AOF日志,不阻塞逻辑线程"}],"id":"6b0d4b4d2136","title":"bgrewriteaof"}],"id":"eab7e5bf6ef9","title":"指令"},{"parent":"9ebcf3c2678e","children":[{"parent":"ae6f7c9912ba","children":[],"id":"f8bb5565a490","title":"开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令,序列化到一个新的AOF日志文件中.序列化完毕后再将操作期间发生的增量AOF日志(有个aof_rewrite_buf)追加到这个新的AOF日志文件中,追加完毕后就立即替代旧的AOF日志文件了,瘦身工作就完成了"}],"id":"ae6f7c9912ba","title":"流程"}],"id":"9ebcf3c2678e","title":"AOF重写"},{"parent":"0f4de7f99036","children":[{"parent":"eb210b86d19e","children":[{"parent":"595bfb56e314","children":[],"id":"eaf2ada7c7b8","title":"生产环境通常使用"}],"id":"595bfb56e314","title":"周期的进行fsync,周期可配置(通常1s)"},{"parent":"eb210b86d19e","children":[],"id":"64abd3d2dd1b","title":"永不fsync,由操作系统来决定合适同步磁盘"},{"parent":"eb210b86d19e","children":[],"id":"c3d5336ea21f","title":"来一个指令就fsync一次"}],"id":"eb210b86d19e","title":"AOF&nbsp;fsync策略"},{"parent":"0f4de7f99036","children":[],"id":"c5819cbf57cf","title":"conf配置:appendonly&nbsp;yes/no"}],"collapsed":false,"id":"0f4de7f99036","title":"AOF日志"},{"parent":"91fbbca9b4ba","children":[{"parent":"ac7e51a31fbd","children":[],"id":"6a487fe51db9","title":"必要性:重启Redis时，我们很少使用rdb来恢复内存状态,因为会丢失大量数据.我们通常使用AOF日志重放,但是重放AOF日志性能相对rdb来说要慢很多,这样在Redis实例很大的情况下,启动需要花费很长的时间"},{"parent":"ac7e51a31fbd","children":[],"id":"b42b47b3f88f","title":"流程:执行bgrewrite时,fork子进程,子进程中将内存中的数据转化为rdb格式内容并写入到AOF日志的开头,之后再写入rdb开始后对应的增量AOF日志"},{"parent":"ac7e51a31fbd","children":[],"id":"15bed935f8a6","title":"conf配置:aof-use-rdb-preamble&nbsp;yes"},{"parent":"ac7e51a31fbd","children":[{"parent":"66fff4ed199a","children":[],"id":"40923cdb0fd5","title":"未开启混合持久化:aof日志以 * 开头"},{"parent":"66fff4ed199a","children":[],"id":"05e3b46a9f0e","title":"开启了混合持久化:aof日志以 REDIS 开头"}],"id":"66fff4ed199a","title":"AOF日志格式"},{"parent":"ac7e51a31fbd","children":[{"parent":"31bdae907380","children":[{"parent":"865f05d22eab","children":[],"id":"49ca2d52f790","title":"加载速度快"},{"parent":"865f05d22eab","children":[],"id":"02e8c838397e","title":"防止丢失大量数据"}],"id":"865f05d22eab","title":"优点"},{"parent":"31bdae907380","children":[{"parent":"1317569405a9","children":[],"id":"f27650c70a4f","title":"因为存在rdb内容,可读写变差"},{"parent":"1317569405a9","children":[],"id":"0ba9d6d1c55d","title":"AOF这种格式不兼容redis 4.0之前的版本"}],"id":"1317569405a9","title":"缺点"}],"id":"31bdae907380","title":"特点"}],"collapsed":false,"id":"ac7e51a31fbd","title":"混合持久化(redis 4.0)"}],"collapsed":false,"id":"91fbbca9b4ba","title":"持久化方式"},{"parent":"2ebb8454e5ca","children":[{"parent":"667f1682db61","children":[],"id":"779dbee804ee","title":"数据安全性:可以考虑是否开启持久化"},{"parent":"667f1682db61","children":[],"id":"ef2628fa0fcb","title":"主从持久化:主节点一般不进行持久化,从节点进行持久化备份"}],"collapsed":false,"id":"667f1682db61","title":"使用注意事项"},{"parent":"2ebb8454e5ca","children":[{"parent":"fe9431907b90","image":{"w":440,"h":630,"url":"http://cdn.processon.com/61b861def346fb2874b9e064?e=1639477230&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TZnTLTFZ5Rx0FjnxVndJsm01J0E="},"children":[],"id":"8ff0b0f03743","title":""}],"collapsed":false,"id":"fe9431907b90","title":"如何恢复数据"}],"collapsed":false,"id":"2ebb8454e5ca","title":"redis持久化  "},{"parent":"a3b7c8685b6a","children":[{"parent":"92a6aa94cd5c","children":[],"id":"eb86a28b21a2","title":"noeviction"},{"parent":"92a6aa94cd5c","children":[{"parent":"944b46d0ed82","children":[],"id":"7eee47366681","title":"<span style=\"font-size: inherit;\">定义:是近似理论上的LRU算法,和下面的allkeys-lru类似,它给每个key增加了一个额外的小字段,这个字段的长度是24个bit,也就是最后一次被访问的时间戳</span><br>"},{"parent":"944b46d0ed82","note":"","children":[],"id":"2f33231225ab","title":"算法原理:当Redis&nbsp;执行写操作时,发现内存超出maxmemory,就会随机采样出5(可以配置)&nbsp;个key放入淘汰池,&nbsp;然后淘汰掉最旧的key,如果淘汰后内存还是超出maxmemory,那就继续随机采样淘汰,直到内存低于maxmemory为止.淘汰算法如何采样就是看maxmemory-policy的配置"},{"parent":"944b46d0ed82","children":[],"id":"8044950cd128","title":"特点:惰性删除,当redis执行写操作的时候才会触发"}],"id":"944b46d0ed82","title":"volatile-lru"},{"parent":"92a6aa94cd5c","children":[],"id":"f57d2442fc73","title":"volatile-ttl"},{"parent":"92a6aa94cd5c","children":[],"id":"f4eac4c405f8","title":"volatile-random"},{"parent":"92a6aa94cd5c","children":[],"id":"9ce0b4225107","title":"allkeys-lru"},{"parent":"92a6aa94cd5c","children":[],"id":"f1b8d7a540a9","title":"allkeys-random"},{"parent":"92a6aa94cd5c","children":[{"parent":"42c9d2129092","children":[],"id":"58ff71354369","title":"定义:算法简单的来说,使用了莫里斯计数器追踪了key的访问频率,根据频率来淘汰key"},{"parent":"42c9d2129092","children":[],"id":"54f4355f0ed0","title":"莫里斯计数器原理:白话来说,莫里斯计数器采用概率计数原理.以浮点类型的前8位作为基础,转化为十进制代表了当前计数器的值(所以范围是0-255),以1/(8位代表的十进制的2的幂)&nbsp;代表当前计数器需要加1的概率"}],"id":"42c9d2129092","title":"volatile-lfu"},{"parent":"92a6aa94cd5c","children":[],"id":"9c37630c794c","title":"allkeys-lfu"}],"collapsed":false,"id":"92a6aa94cd5c","title":"redis内存淘汰策略"},{"parent":"a3b7c8685b6a","children":[{"parent":"3f826ea6277d","children":[],"id":"d67d9a5d53a1","title":"过期策略:将设置了过期时间的key放入一个独立的字典中,采用定时或者惰性删除的方式进行处理"},{"parent":"3f826ea6277d","children":[{"parent":"3ca442dd07f9","children":[{"parent":"222ea266dbf9","children":[],"id":"8b6b4de40925","title":"每秒执行十次扫描,每次扫描时间上限是25ms<br>"},{"parent":"222ea266dbf9","children":[],"id":"90884b04cc00","title":"从上面独立字典中随机挑选20个key,删除其中过期的key,如果过期的key占据了1/4,再次执行,直到比例小于1/4<br>"}],"id":"222ea266dbf9","title":"定时策略"},{"parent":"3ca442dd07f9","children":[],"id":"111538fc54cc","title":"惰性删除:每次访问key判断有没有过期,如果过期,删除即可"}],"id":"3ca442dd07f9","title":"主库"},{"parent":"3f826ea6277d","children":[{"parent":"62bc8014c9dd","children":[],"id":"32724a98c0df","title":"异步同步主库的数据(主库通过在aof文件中添加del命令的方式)"}],"id":"62bc8014c9dd","title":"从库"},{"parent":"3f826ea6277d","children":[{"parent":"1bfbfca7f424","children":[],"id":"8f01b6754436","title":"如果可能存在大量key集中过期的情况,设置key的过期时间应当是过期时间time附近的随机范围,避免key集中过期"}],"id":"1bfbfca7f424","title":"注意事项"}],"collapsed":false,"id":"3f826ea6277d","title":"redis过期策略"},{"parent":"a3b7c8685b6a","children":[{"parent":"0a1f1a255ca6","children":[],"id":"5fd750ca84ae","title":"定义:事务的指令需一起执行"},{"parent":"0a1f1a255ca6","children":[{"parent":"bc44e835e474","children":[],"id":"ad67ca8833e4","title":"和关系型数据库事务不同,仅满足隔离性,当前执行的事务不会被其他事务所打断"},{"parent":"bc44e835e474","children":[],"id":"7a7ec2fc60da","title":"批量指令中如果执行失败,不影响后面指令的执行"}],"id":"bc44e835e474","title":"特点"},{"parent":"0a1f1a255ca6","children":[{"parent":"5c3400c3396f","children":[],"id":"9043f53ae7f4","title":"multi"},{"parent":"5c3400c3396f","children":[],"id":"7fcccd76cb18","title":"exec"},{"parent":"5c3400c3396f","children":[],"id":"a51fe8380bfd","title":"discard"}],"id":"5c3400c3396f","title":"命令"},{"parent":"0a1f1a255ca6","children":[{"parent":"91674b9f6329","children":[],"id":"cdb5d2582700","title":"不优化:客户端开启事务后,每一次都会将一个指令发送到redis服务器缓存,就会存在多次网络IO的问题"},{"parent":"91674b9f6329","children":[],"id":"8fd5fa6c1cb4","title":"优化:利用redis pipeline机制进行事务的优化,将多次IO压缩成一次IO"}],"id":"91674b9f6329","title":"优化"}],"collapsed":false,"id":"0a1f1a255ca6","title":"redis事务"},{"parent":"a3b7c8685b6a","children":[{"parent":"a2fbaacbd981","children":[{"parent":"bb841783e7ae","children":[],"id":"9cf4cf1cb392","title":"lua脚本机制:比较常用"},{"parent":"bb841783e7ae","children":[{"parent":"ccdb48ff1a9d","children":[],"id":"31d2f10f7a1e","title":"乐观锁机制"},{"parent":"ccdb48ff1a9d","children":[],"id":"7c8a5aab0a49","title":"常和redis事务一起使用"}],"id":"ccdb48ff1a9d","title":"redis watch机制"},{"parent":"bb841783e7ae","children":[],"id":"25b6a9aec94f","title":"redis分布式锁"},{"parent":"bb841783e7ae","children":[{"parent":"774987d07728","children":[],"id":"462f7c4648a8","title":"严格上并不能处理并发,执行的操作必须是redis本身提供的,并且要和事务一起使用,利用事务的隔离性"},{"parent":"774987d07728","children":[],"id":"59dc3f8965be","title":"如果涉及到的操作redis不支持,需要读到客户端的内存进行操作,那么需要配置redis watch机制才能实现并发控制"}],"id":"774987d07728","title":"redis事务"}],"id":"bb841783e7ae","title":"单实例"},{"parent":"a2fbaacbd981","children":[{"parent":"76735f4147c2","children":[],"id":"f95543a43658","title":"redis分布式锁"}],"id":"76735f4147c2","title":"多实例"}],"collapsed":false,"id":"a2fbaacbd981","title":"redis处理并发"}],"collapsed":true,"id":"a3b7c8685b6a","title":"redis基础"},{"parent":"root","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"3737a9b1eb01","children":[],"id":"1fea27b6b9b6","title":"配置"},{"parent":"3737a9b1eb01","children":[{"parent":"03cc9f5b09a9","children":[],"id":"7d40851e1784","title":"数据冗余备份,提升数据安全性"},{"parent":"03cc9f5b09a9","children":[],"id":"ab51b69bcec7","title":"进行读写分离,降低mater负载"}],"id":"03cc9f5b09a9","title":"作用"},{"parent":"3737a9b1eb01","children":[{"parent":"ccc70f83eab8","children":[],"id":"f4c5bfa18d72","title":"准备阶段:握手交换数据(replicationID,offset)等等"},{"parent":"ccc70f83eab8","children":[{"parent":"0178d5882694","children":[{"parent":"e69c96c440ec","children":[],"id":"ee19ce2f4157","title":"存盘同步:master先在本地存RDB文件,再将其通过socket发送到replicas,replicas先存入磁盘,在load入内存"},{"parent":"e69c96c440ec","children":[],"id":"0c0cb8ed5723","title":"无盘同步:master直接内存快照数据转换为RDB文件内容形式通过socket发送到replicas,replicas存入磁盘,在load入内存"}],"id":"e69c96c440ec","title":"全量同步"},{"parent":"0178d5882694","children":[],"id":"80d6951dfe10","title":"部分同步:master将backlog(复制积压缓冲区的内容)根据replicas发送过来的offset将增量发送给replicas"}],"id":"0178d5882694","title":"同步阶段(psync)"},{"parent":"ccc70f83eab8","children":[],"id":"d73f3f5256fc","title":"命令传播阶段:master将使内存改变的命令同步到replicas"}],"id":"ccc70f83eab8","title":"主从同步流程"},{"parent":"3737a9b1eb01","children":[{"parent":"bf8a7d9f66ba","children":[{"parent":"63fbb263ad26","children":[],"id":"6f74eb61c9c8","title":"replica 第一次连入master"},{"parent":"63fbb263ad26","children":[],"id":"0c5183258e13","title":"replica不满足部分同步条件"},{"parent":"63fbb263ad26","children":[],"id":"7fea3e4b54c8","title":"redis 4.0之前master故障转移"}],"id":"63fbb263ad26","title":"全量同步"},{"parent":"bf8a7d9f66ba","children":[{"parent":"54f9a5c6df04","children":[],"id":"1ab32762412f","title":"replica的replicationID == master runid"},{"parent":"54f9a5c6df04","children":[],"id":"6c3833da4169","title":"replica的offset不合法(包括溢出等等)"},{"parent":"54f9a5c6df04","children":[],"id":"46f4187b60e5","title":"redis 4.0及之后的版本master故障转移"},{"parent":"54f9a5c6df04","children":[],"id":"3895bfb7c0ad","title":"其他满足部分同步条件"}],"id":"54f9a5c6df04","title":"部分同步"}],"id":"bf8a7d9f66ba","title":"同步方式选择"},{"parent":"3737a9b1eb01","children":[{"parent":"887edf9d4f30","children":[{"parent":"490b5f1b0f63","children":[{"parent":"9db58ef65158","children":[],"id":"90e8f20b2ba6","title":"建议开启master持久化"},{"parent":"9db58ef65158","children":[],"id":"6681485498e4","title":"禁止master自启动,否则可能导致数据丢失"}],"id":"9db58ef65158","title":"master关闭了持久化"}],"id":"490b5f1b0f63","title":"master故障转移"},{"parent":"887edf9d4f30","children":[{"parent":"2176562d9488","children":[],"id":"1a4d65320b55","title":"正常主从同步,但是数据量太大,时间过长,导致master的backlog溢出"},{"parent":"2176562d9488","children":[],"id":"166d7e8f27a3","title":"网络环境不好,导致同步时间过长,backlog溢出"}],"id":"2176562d9488","title":"backlog(复制积压缓冲区)溢出,需设置其合理大小"}],"id":"887edf9d4f30","title":"注意事项"}],"collapsed":true,"id":"3737a9b1eb01","title":"redis主从"},{"parent":"root","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"6868841bbe42","children":[],"id":"633e93ef3e94","title":"哨兵模式定义"},{"parent":"6868841bbe42","children":[{"parent":"b4179c2c4e1a","children":[],"id":"b46c6210b05b","title":"监控服务是否正常运行"},{"parent":"b4179c2c4e1a","children":[],"id":"bc26b7735a41","title":"当服务出现故障时进行提醒"},{"parent":"b4179c2c4e1a","children":[],"id":"827c0e1a08f0","title":"自动故障转移"}],"collapsed":false,"id":"b4179c2c4e1a","title":"哨兵作用"},{"parent":"6868841bbe42","children":[{"parent":"22652dc66820","children":[],"id":"aa8d05905b28","title":"redis-sentinel安装"},{"parent":"22652dc66820","children":[{"parent":"01f80963099e","children":[{"parent":"ac5ebe36463e","children":[],"id":"078cfceb227c","title":"使maser从SDOWN变为ODOWN最少哨兵节点数量，mater ODOWN之后,才可以真正开始故障转移操作"},{"parent":"ac5ebe36463e","children":[{"parent":"9e9d9456c0b3","children":[{"parent":"3b84f851f344","children":[],"id":"af206eabe9a9","title":"quorum &lt; total/2(向上取整)， agree = total/2(向上取整)"},{"parent":"3b84f851f344","children":[],"id":"14e01872e61f","title":"quorum &gt;= total/2(向上取整), agree = quorum"}],"id":"3b84f851f344","title":"&nbsp;quorum"},{"parent":"9e9d9456c0b3","children":[],"id":"b8fcaac579bf","title":"实际agree的值必须 &gt;= quorum 才会真正进行故障转移操作"}],"id":"9e9d9456c0b3","title":"选举执行故障转移操作leader所需要的最少哨兵节点数量"}],"id":"ac5ebe36463e","title":"重点:quorum"}],"id":"01f80963099e","title":"配置文件相关配置"}],"collapsed":false,"id":"22652dc66820","title":"哨兵模式配置"},{"parent":"6868841bbe42","children":[{"parent":"99439ce650c2","children":[],"id":"596e2582c904","title":"1. master处于ODOWN"},{"parent":"99439ce650c2","children":[],"id":"c6f622b60e99","title":"2. 在故障转移选举中成为leader"},{"parent":"99439ce650c2","children":[],"id":"91151acc9c4b","title":"3. 选择一个从服务器作为主服务器, 并通过命令将此从服务器提升为主服务器"},{"parent":"99439ce650c2","children":[],"id":"5493c40d258c","title":"4. 将配置同步到其他哨兵节点"},{"parent":"99439ce650c2","children":[],"id":"44037cb4e7d3","title":"5. 让其他从节点复制新的主节点数据"},{"parent":"99439ce650c2","children":[],"id":"0961d9056c40","title":"6. 故障转移结束"}],"collapsed":false,"id":"99439ce650c2","title":"哨兵故障转移过程"},{"parent":"6868841bbe42","children":[{"parent":"025e473a370b","children":[],"id":"31b1d9a3474e","title":"排除处于异常状态的从服务器,比如SDOWN ODOWN等"},{"parent":"025e473a370b","children":[],"id":"92ae16b91367","title":"排除与master断链超过一定时间的((down-after-milliseconds&nbsp;*&nbsp;10)&nbsp;+&nbsp;milliseconds_since_master_is_in_SDOWN_state)"},{"parent":"025e473a370b","children":[{"parent":"178697766b65","children":[],"id":"74e7c8a50007","title":"值越小,优先级越高"},{"parent":"178697766b65","children":[],"id":"be6234e50d28","title":"值为0 不参与选择"}],"id":"178697766b65","title":"Replica&nbsp;priority"},{"parent":"025e473a370b","children":[],"id":"734f94f5f1ba","title":"Replication&nbsp;offset&nbsp;processed: 值越大越容易被选中"},{"parent":"025e473a370b","children":[],"id":"1146eb04c23e","title":"RunId: 越小越容易被选中"}],"collapsed":false,"id":"025e473a370b","title":"选择Replication依据"},{"parent":"6868841bbe42","children":[{"parent":"f089f4a20cb1","children":[],"id":"c1e674c8211b","title":"问题描述:类似于脑裂,如果发生此问题,导致minority side 丢失部分写数据"},{"parent":"f089f4a20cb1","children":[{"parent":"94453472f9db","children":[],"id":"c986799f257c","title":"min-replicas-to-write&nbsp;1"},{"parent":"94453472f9db","children":[],"id":"33083080df4a","title":"min-replicas-max-lag&nbsp;10"}],"id":"94453472f9db","title":"最大减少丢失部分写数据的时间窗口"},{"parent":"f089f4a20cb1","children":[],"id":"ca6ff9e8748d","title":"正确配置后如果master不能和至少一个repilca进行同步并且acknownlage延迟在10s之内, master将停止写请求"}],"collapsed":false,"id":"f089f4a20cb1","title":"网络分区处理"},{"parent":"6868841bbe42","children":[{"parent":"58c4397d99a7","children":[],"id":"4f08de0392e9","title":"有的库内部已经封装实现"},{"parent":"58c4397d99a7","children":[],"id":"39d8395e92fc","title":"客户端在出现异常是使用命令进行获取新master地址:&nbsp; SENTINEL&nbsp;get-master-addr-by-name&nbsp;mymaster"},{"parent":"58c4397d99a7","children":[],"id":"e744e2ce6f83","title":"通过pub/sub机制,客户端订阅&nbsp;switch-master 主题事件, sentinel故障转移完成后主动通知客户端"}],"collapsed":false,"id":"58c4397d99a7","title":"故障通知"}],"collapsed":true,"id":"6868841bbe42","title":"redis哨兵"}],"root":true,"theme":"delicate_caihong","id":"root","title":"redis","structure":"mind_free"}},"meta":{"exportTime":"2022-03-12 16:19:20","member":"616fddd81efad42eb5ecab9b","diagramInfo":{"creator":"616fddd81efad42eb5ecab9b","created":"2022-03-12 16:06:58","modified":"2022-03-12 16:16:35","title":"redis","category":"mind_free"},"id":"622c54a25653bb074b1321f3","type":"ProcessOn Schema File","version":"1.0"}}