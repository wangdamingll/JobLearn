# 算法
---  
## [wiki 算法基础](https://oi-wiki.org/basic/)  
## 排序算法  
### 1. 冒泡排序  
* 解决问题  
1. 排序问题  
* 时间复杂度  
O(N^2) 最好的时间复杂度O(N)  
* 算法思想  
1. 均是前一项同后一项进行比较  
* 算法特点  
1. 相邻元素之间比较  
2. 经过i次扫描后,数列的末尾i项必然是最大(小)的i项,就是每轮必定将最值放到末尾  
3. 如果数列为n个,最多需要处理n-1轮即可 
4. 稳定排序   
* 代码示例  
[冒泡排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/BubbleSort)  

### 2. 选择排序  
* 解决问题  
1. 排序问题  
* 时间复杂度  
O(N^2)
* 算法思想  
1. 选择排序是在每一趟查找最大值(或最小值),并标记该最大值的下标位置.如果该趟查找完毕之后,最大值下标和当前i的元素下标不同,就开始交换.  
2. 每一趟都会有一个元素的最终位置被确定  
* 算法特点  
1. 标记每轮起始元素,并从其后一位开始到结束与起始元素相比,选择最值后交换  
2. 不稳定排序  
* 代码示例  
[选择排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/SelectSort)  

### 3. 插入排序  
* 解决问题  
排序问题  
* 时间复杂度  
1. 最坏和平均的时间复杂度均为:O(N^2)  最好的时间复杂度O(N)  
* 算法思想  
插入排序将数列划分为"已排序的"和"未排序的"两部分,每次从"未排序的"元素中选择一个插入到"已排序的"元素中的正确位置  
* 算法特点  
1. 插入排序第一趟是将第一个元素视为有序,从第二个元素(索引为i)开始与它的前一个元素比较,如果比它前一个元素小(升序),就将arr[i]临时存放,将i前面比arr[i]大的元素往后移动一位,直到前一元素比arr[i]小,最后将arr[i]插入到正确位置  
2. 把数拿出来(产生坑)->比较->把数放回去(填坑)  
3. 在数列几乎有序的时候效率很高  
3. 稳定排序  
* 代码示例  
[插入排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/InsertSort)  

### 4. 希尔排序  
* 解决问题  
排序问题  
* 时间复杂度  
1. 平均时间复杂度:O(N^(3/2))  
2. 最差时间复杂度:O(n*log2n)  
* 算法思想  
希尔排序相当于插入排序的加强版,它将一个待排序数组以步长step分为N组,在每组中执行插入排序操作,插入排序可以看成是步长为1的希尔排序  
* 算法特点  
1. 元素分组 + 插入排序
2. 不稳定排序
3. 数列中等大小规模表现良好,对规模非常大的数据排序不是最优选择  
4. 几乎任何排序工作在开始时都可以用希尔排序,若在实际使用中证明它不够快,再改成快速排序这样更高级的排序算法  
* 代码示例  
[希尔排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/ShellSort)  

### 5. 快速排序  
* 解决问题  
排序问题  
* 算法思想:  
1. 二分法思想  
2. 分而治之思想
* 时间复杂度:  
1. 最坏的时间复杂度:O(N^2)  
2. 平均时间复杂度:O(NlogN)  
* 算法特点:  
1. 数据越有序,越快  
2. 不稳定排序  
* 代码示例    
[快速排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/QuickSort)  

### 6. 归并排序    
* 解决问题  
1. 排序问题  
2. 求逆序对的个数  
* 算法思想:  
1. 分治思想    
2. 递归思想
* 时间复杂度:  
O(NlogN)  
* 算法特点:  
1. 归并排序 = 归并排序主体递归 + 合并算法  
2. 归并排序的主体部分的temp参数是主调函数分配内存  
3. 合并其实是递归回溯的时候自下而上的合并  
4. 该排序可以说是以空间换时间的排序算法  
5. 稳定排序  
* 代码示例    
[归并排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/MergeSort)  


### 7. 桶排序  
* 解决问题  
1. 排序问题  
2. 可以统计某个数出现的次数 
3. 可以对某个数出现进行标记(记数排序)
* 时间复杂度  
期望的时间复杂度:O(N)  
* 算法思想  
1. 对值域进行分块,每块分别排序.由于每块元素不多,一般使用插入排序.如果使用稳定的内层排序,并且将元素插入桶中时不改变相对顺序,那么桶排序就是稳定的.  
* 算法特点  
1. 适用于待排序数据值域较大但分布比较均匀的情况  
2. 如果要排序的数组非常大且有规律或者大体分布均匀或者通过某种方式能够对数据进行放大缩小,可以考虑桶排序  
* 代码示例  
[桶排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/BucketSort)  

### 8. 堆排序  
* 解决问题  
1. 排序问题  
2. 找出一组数中第K大(小)的问题
* 时间复杂度  
O(NlogN)  
* 算法特点  
1. 不稳定排序
* 代码示例  
[堆排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/HeapSort)  

### 9. 基数排序  
* 解决问题  
1. 排序问题(非比较排序)  
* 算法思想:  
1. "多关键字排序"  
* 时间复杂度:  
1. 时间复杂度:O(d(n+r)):其中d为元素的关键字位数,n为元素个数,r为关键字的取值范围,即桶的个数.  
2. 空间复杂度为:O(r)  
* 算法特点:  
1. 可以最高位优先
2. 可以最低位优先
3. 先分配,再收集
4. 需要知道源数据所有位的最大数以确定桶的数量
5. 稳定排序  
* 代码示例    
[基数排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/RadixSort)  

### 10. 快速选择    
* 解决问题  
在一组数据中找出第k小的数    
* 算法思想:  
1. 二分法思想  
2. 分而治之思想
* 时间复杂度:  
1. 最坏的时间复杂度:O(N^2)  
2. 平均时间复杂度:O(N)  
* 算法特点:  
1. 属于快排变形算法,每次只对一半进行递归处理  
2. 会对原数据进行破坏  
* 代码示例    
[快速选择](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/QuickSelect)      

### 11. 图的拓扑排序      
* 图相关概念:  
1. 有向无环图:如果一个有向图的任意顶点都无法通过一些有向边回到自身,那么称这个有向图为有向无环图.  
* 拓扑排序概念:  
拓扑排序是将有向无环图的所有顶点排成一个线性序列,使得对图中的任意两个顶点u v,如果存在边u->v,那么在序列中u一定在v前面,这个序列又被称为拓扑序列.说直白点:拓扑排序,就是用来确定事物发生的顺序的.  
* 时间复杂度  
O(N+M),N为顶点数,M为边数(因为图广度搜索共处理N个顶点,将所有顶点的度都处理到0(其实就是边的数量))  
* 拓扑排序算法实现:  
1. 可以借助图的广度优先搜索算法(BFS)  
2. 可以借助图的深度优先搜索算法(DFS)  
* 拓扑排序算法应用:  
1. 借助有向无环图描述一系列任务关系,用拓扑排序来确定这一系列任务发生的顺序  
2. 可以判断有向图是否存在闭环  
* [拓扑排序代码](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/TPSort)  

## 贪婪算法  
### 定义  
* 每步都选择局部最优解,最终得到的就是全局最优解.属于近似算法的一种  
### 算法应用  
主要为了解决NPC问题.如下:    
* 背包问题  
注意,此类问题贪婪算法虽然能得到解,但不是最优解,但是非常接近  
* 集合覆盖问题  
1. 时间复杂度为:O(2^N)  
2. [示例代码](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/SetCover)  
* 旅行商问题  
1. 时间复杂度为:O(N!)  
2. 可以考虑使用Dijskstra算法得到近似解  
3. [示例代码](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/TSP)  
* 调度问题  
1. 有一堆作业要完成,每次只能完成一个,那么每次都完成消耗时间最少的作业,就能够最早的完成所有作业  
* 文件压缩---哈夫曼编码
1. 每次均选出现频率最小的2个节点合并成一颗树  
* 近似装箱问题  
1. 联机算法:下项适合算法、首项适合算法、最佳适合算法  
2. 脱机算法:首次适合递减算法、最佳适合递减算法  
3. [近似装箱算法简介](https://blog.csdn.net/wangdamingll/article/details/106387260)  
### 如何识别NPC问题  
1. 元素较少时算法的运行速度非常快,但随着元素数量的增加,速度会变得非常慢.  
2. 涉及"所有组合"的问题通常是NPC问题.    
3. 不能将问题分成小问题,必须考虑各种可能的情况.这可能是NPC问题.    
4. 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决,它可能就是NPC问题.    
5. 如果问题涉及集合(如广播台集合)且难以解决,它可能就是NPC问题.    
6. 如果问题可转换为集合覆盖问题或旅行商问题,那它肯定是NPC问题.    

## 动态规划  
### 定义  
白话说就是一种解决棘手问题的方法,它将问题分成小问题,并先着手解决这些小问题,最后得到最优解  
### 算法应用  
一般问题:下一步需要用到上一步计算结果    
* [斐波那契数列计算](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Fib)  
特殊问题:通常需要在给定约束条件下优化某种指标时应用,如下:  
* 背包问题  
要高度注意:"背包"可不仅仅是指例子中物理的背包,是指一种约束条件.比如说要在规定时间去旅游,那么这个"背包"就是时间!    
1. [小偷偷东西示例代码](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/ThiefBackPack)    
2. 旅游问题:和上面小偷偷东西代码基本相似,行代表旅游地点,列代表每个地点耗费天数,网格值代表想去该地点的期望值,都采用相同的网格计算公式,这里不再给出示例代码     
* 最长公共子串(子序列)问题  
1. [最长公共子串长度](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/LongestCommonSubStr)  
2. [最长公共子序列](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/LongestCommonSubSeq)  
* [最优二叉查找树](https://blog.csdn.net/xiajun07061225/article/details/8088784)  
### 算法特点  
1. 动态规划可帮助你在给定约束条件下找到最优解.在背包问题中,你必须在背包容量给定的情况下,偷到价值最高的商品.  
2. 在问题可分解为彼此独立且离散的子问题时,就可使用动态规划来解决(很重要)    
### 算法通用小贴士  
1. 每种动态规划解决方案都涉及网格    
2. 单元格中的值通常就是你要优化的值.在前面的背包问题中,单元格的值为商品的价值.  
3. 每个单元格都是一个子问题,因此你应考虑如何将问题分成子问题,这有助于你找出网格的坐标轴.  
4. 没有放之四海皆准的计算动态规划解决方案的公式.  

## 回溯算法  
### 定义  
回溯算法实际上一个类似枚举的搜索尝试过程,主要是在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就"回溯"返回,尝试别的路径.  
回溯法是一种选优搜索法,按选优条件向前搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为"回溯点".
许多复杂的,规模较大的问题都可以使用回溯法,有"通用解题方法"的美称.
### 算法应用
1. [全排列问题](https://github.com/wangdamingll/JobLearn/blob/master/prepare/algorithm/code/DFS/DFS1.hpp)  
2. [迷宫问题](https://github.com/wangdamingll/JobLearn/blob/master/prepare/algorithm/code/DFS/DFS3.hpp)  
3. [独立子图问题](https://github.com/wangdamingll/JobLearn/blob/master/prepare/algorithm/code/DFS/DFS4.hpp)    
4. 博弈问题  


## 搜索算法

### 1. 枚举算法
* 算法思想:  
  有序的去尝试每一种可能
* 注意事项:  
1. 尽可能先做逻辑判断，减少枚举数字的范围和需要枚举的个数，从而降低整体的时间复杂度
* 枚举算法的应用:  
1. 全排列系列问题  
2. 火柴棍问题
* [代码示例](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/enumeration)

### 2. 不撞南墙不回头-----深度优先搜索
* 算法(Depth First Search)的思想:  
1. 首先以一个未被访问过的顶点作为起始顶点,沿当前顶点的边走到未访问过的顶点;当没有未访问过的顶点时,则回到上一个顶点,继续试探访问别的顶点,直到所有的顶点都被访问过.
   显然，深度优先遍历是沿着某一条分支遍历直到末端,然后回溯,再沿着另一条进行同样的遍历,直到所有的顶点都被访问过为止.
2. 理解DFS的关键:DFS在于解决"当下该如何做"，至于"下一步如何做"和"当下该如何做"是一样的  
3. 实现的方法一般是递归调用自己  
* 时间复杂度  
  不涉及逻辑,纯算法时间复杂度O(N^2)
* DFS的基本模型
```C++
  void dfs(int step)
  {
      //判断边界
      //满足条件则返回
      //尝试每一种可能
      for(int i = 1; i < n; i++)
      {
           //继续下一步
           dfs(step + 1); 
      }
     //返回
 }
```
* 算法的应用:    
1. 全排列问题
2. 迷宫问题(连通图问题)-----时间复杂度不止O(N^2)   
3. 图中独立子图个数(种子填充法)
4. 图遍历-----(请查看下文图遍历算法)
* [代码示例](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/DFS)

### 3. 层层递进---广度优先搜索
* 算法思想:  
1. 首先以一个未被访问过的顶点作为起始顶点,访问其所有相邻的顶点,然后对每个相邻的顶点,再访问它们相邻的未被访问过的顶点，直到所有顶,点都被访问过,遍历结束.  
* 时间复杂度  
不涉及逻辑,时间复杂度:O(V+E)，V为顶点个数，E为边的条数 空间复杂度:O(V)   
* 算法应用:
1. 迷宫问题(连通图问题)--------O(N^2)         
2. 图遍历------适合边权一样的情况(请查看下文图遍历算法)
* [代码示例](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/BFS)


## 图
### 1. 图定义  
简单的说,图就是由一些小圆点(称为顶点)和连接这些小圆点的直线(称为边)组成的.
### 2. 图分类  
图可以分为无向图和有向图  
### 3. 图存储  
邻接矩阵存储法 邻接表存储法
### 4. 图遍历
#### 1. 深度优先搜索(DFS)
##### 图遍历DFS思想
首先以一个未被访问过的顶点作为起始顶点,沿当前顶点的边走到未访问过的顶点;当没有未访问过的顶点时,则回到上一个顶点,继续试探访问别的顶点,直到所有的顶点都被访问过.显然,深度优先遍历是沿着图的某一条分支遍历直到末端,然后回溯,再沿着另一条进行同样的遍历,直到所有的顶点都被访问过为止.  
##### 图遍历DFS时间复杂度  
O(V+E),V是顶点数,E是边数(对访问过的点进行标记,这样每一条边只会访问一次,每一个顶点只会访问一次)    
##### 代码地址
[图遍历DFS---无向图和有向图](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Map)
#### 2.广度优先搜索(BFS)  
##### 图遍历BFS思想
首先以一个未被访问过的顶点作为起始顶点,访问其所有相邻的顶点,然后对每个相邻的顶点,再访问它们相邻的未被访问过的顶点,直到所有顶点都被访问过,遍历结束. 
##### BFS特点  
单纯的图遍历使用BFS来说,BFS不仅查找从A到B的路径,而且找到的是最短的路径(非加权图或者加权图(图边权相同),并且使用队列按顺序添加节点).  
##### 图遍历BFS时间复杂度  
O(V+E),V是顶点数,E是边数(因为每个顶点需要出入队列,需要检查所有边)  
##### BFS算法应用  
处理非加权图或者加权图(权都相同)的以下问题:  
1. 从节点A出发,有前往节点B的路径吗?  
2. 从节点A出发,前往节点B的哪条路径最短?  
##### 代码地址
[图遍历BFS---无向图](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Map)

## 图最短路径
### 1. 深度优先搜索算法(DFS)  
* 解决问题  
求图中多源(全源)最短路问题  
* 时间复杂度  
纯算法时间复杂度O(N^2)
* 代码示例
[最短路径DFS---无向图和有向图](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Map)

### 2. 广度优先搜索算法(BFS)
* 解决问题  
求图中(非加权图或者加权图(权都相同))多源(全源)最短路问题  
有向图和无向图计算都支持    
* 时间复杂度  
O(V+E),V是顶点数,E是边数(因为每个顶点需要出入队列,需要检查所有边)  
* 特点  
比深度优先算法块,更加适用于边权相同的情况  
* 代码示例  
[最短路径BFS---无向图](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Map)

### 3. Floyd-Warshall(弗洛伊德算法----只有五行的算法)  
* 解决问题  
求图中多源(全源)最短路问题  
* 时间复杂度  
O(N^3)
* 特点  
1. 非常简单,只有五行    
2. 可以求图中全源最短路问题
3. 也可以求单源最短路问题(指定一个顶点到其余各个顶点的最短路径)
4. 图中边权可以有负值,但是不可以含有负权循环  
* 代码示例  
[Floyd-Warshall](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Floyd-Warshall)  

### 3. Dijkstra  
* 解决问题  
1. 求加权图中单源最短路问题(总权重和最小)    
2. 请注意,"最短路径"含义是某种度量指标最小!并不一定是物理的最短路径,比如也可以是花钱最少,耗费时间最少等等问题  
3. 也可以求解无权图的单源最短路(可以看做每次dis+1)  
* 时间复杂度  
1. 用一般的图的邻接矩阵法存的话,时间复杂度为O(N^2)
2. 对于稀疏图来说,用堆和邻接表存储法,可以将时间复杂度优化为O((M+N)logN),N为顶点数,M为边数.最坏的情况M等于N^2,那么O((M+N)logN)比O(N^2)大,但是一般来说边没有那么多,所以O((M+N)logN)比O(N^2)小很多
* 特点      
1. 可以求加权图中单源最短路问题(总权重和最小)  
2. 时间复杂度为O(N^2),可以优化为O((M+N)logN),N为顶点数,M为边数    
3. 图中边权不可以有负值  
* 优化  
1. 可以使用堆进行优化:用堆(最小堆)查找出dis中每次最小路程的点(当然也可以用配对堆进行优化)    
2. 如果是稀疏图,可以使用邻接表存储图法进行优化
* 代码示例  
[图邻接表存储法](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Dijkstra)  
[Dijkstra](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Dijkstra)  

### 4. Bellman-Ford  
* 解决问题  
1. 求图中单源最短路问题  
2. 求图中是否存在负权回路
* 时间复杂度  
1. 未使用队列优化过的:O(NM),N为顶点 M为边  
2. 使用队列优化过的,最坏的时间复杂度是O(NM),N为顶点 M为边
* 特点      
1. 是一个无论是思想上还是代码实现上都堪称完美的最短路算法,核心代码只有4行
2. 可以处理带有负权边的图
3. 经常会在未达到n-1轮松弛前就已经计算出最短路(最多进行n-1轮边的松弛操作,n为顶点数量)  
* 优化  
1. 经常会在未达到n-1轮松弛前就已经计算出最短路,所以这时可以跳出循环,做优化
2. 可以使用队列进行优化:每次仅对最短路程发生变化了的点的相邻边执行松弛操作,使用队列保存这些最短路程变化了的点
* 代码示例  
[图邻接表存储法](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Bellman-Ford)  
[Bellman-Ford](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/Bellman-Ford)  

## 图最小生成树  
### 1. 相关概念  
* 连通图:在无向图中,若任意两个顶点vi与vj都有路径相通,则称该无向图为连通图.
* 强连通图:在有向图中,若任意两个顶点vi与vj都有路径相通,则称该有向图为强连通图.
* 连通网:在连通图中,若图的边具有一定的意义,每一条边都对应着一个数,称为权;权代表着连接连个顶点的代价,称这种连通图叫做连通网.
* 生成树:一个连通图的生成树是指一个连通子图,它含有图中全部n个顶点,但只有足以构成一棵树的n-1条边.一颗有n个顶点的生成树有且仅有n-1条边,如果生成树中再添加一条边，则必定成环.
* 最小生成树:在连通网的所有生成树中,所有边的代价和最小的生成树,称为最小生成树.  
### 2. 算法应用  
总的思想:求图中所有顶点最小生成树,即路程最短or材料消耗最少.....  
1. 畅通工程问题  
2. 镖局运输问题
3. ...
### 3. 相关算法
#### Kruskal算法  
* [算法示例](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/MapBuildMinTree)

#### Prim算法  
* [算法示例](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/MapBuildMinTree)  

## 图的割点  
### 1. tarjan算法  
#### * 算法应用  
割点定义:如果去掉一个点以及与它连接的边,该点原来所在的图被分成两部分(不连通),到底什么问题才能用到呢?  
1. 比如炸毁城市问题---炸毁城市群中某个城市,导致所有城市群不在能运输物资？  
#### * 时间复杂度:
1. 深度优先遍历或广度优先遍历:O(N(N+M))
2. tarjan算法:  
用邻接矩阵存储:O(N^2)  
用邻接表存储:O(N+M)  
#### * 算法特点:
1. 需要用DFS遍历图的所有顶点,记录num[顶点编号] = 顶点深度遍历时间戳
2. 当遍历到顶点u时,枚举顶点u的所有出边,比如v,如何知道v不经过父节点u能否回到祖先节点呢?对子节点v再次DFS
3. 需要记录每个子节点v在不经过父节点u的情况下,能够回到的最小时间戳(若存在v的父节点不止u一个的情况下):lows[v] = min(lows[v],nums[f])
4. v回溯的时候获取当前节点的最小时间戳low[u]=min(low[u],low[v]),如果low[v]>=num[u],表示v不能不经过u回到祖先,即u为割点   
#### * 代码示例  
[图割点--tarjan](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/MapCutPoint)  

## 图的割边  
### 1. tarjan算法  
#### * 算法应用  
割边定义:在一个无向连通图中,如果删掉某条边后,该图不在连通,到底什么问题才能用到呢?  
1. 比如炸毁城市问题---炸毁城市群中某个城市,导致所有城市群不在能运输物资？  
#### * 时间复杂度:
1. 深度优先遍历或广度优先遍历:O(N(N+M))
2. tarjan算法:  
用邻接矩阵存储:O(N^2)  
用邻接表存储:O(N+M)  
#### * 算法特点:
1. 需要用DFS遍历图的所有顶点,记录num[顶点编号] = 顶点深度遍历时间戳
2. 当遍历到顶点u时,枚举顶点u的所有出边,比如v,如何知道v不经过父节点u能否回到祖先节点呢?对子节点v再次DFS
3. 需要记录每个子节点v在不经过父节点u的情况下,能够回到的最小时间戳(若存在v的父节点不止u一个的情况下):lows[v] = min(lows[v],nums[f])
4. v回溯的时候获取当前节点的最小时间戳low[u]=min(low[u],low[v]),如果low[v]>=num[u],表示v不能不经过u回到祖先,即u为割点,如果low[v]>num[u],表示v不经过u,也没有其他的父节点,即u<->v是割边
#### * 代码示例  
[图割边--tarjan](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/MapCutEdge)  
  
## 二分图最大匹配  
### 1. 无权二分图最大匹配---匈牙利算法  
#### * 算法应用  
根据定义,就是在满足条件情况下,能够匹配的最大数量  
1. 比如男女相亲问题
2. 比如在某种情况下需要求道路(边)最多
3. ....  
#### * 时间复杂度:
用邻接表存储:O(NM)  
#### * 算法特点:
1. 首先从任意一个未被配对的点u开始,从点u的边中任意选一条边(假设这条边是u→ν)开始配对,如果此时点v还没有被配对,则配对成功.此时便找到了一条增广路(只不过这条增广路比较简单).  
如果此时点v已经被配对了,那就要尝试进行"连锁反应".如果尝试成功了,则找到一条增广路,此时需要更新原来的配对关系.这里要用一个数组match来记录配对关系,比如点v与点配对了,就记作match[v]=u和match[u]=v配对成功后,记得要将配对数加1.  
配对的过程我们可以通过深度优先搜索来实现,当然广度优先搜索也可以.
2. 如果刚才所选的边配对失败,要从点u的边中再重新选一条边,进行尝试.直到点u配对成功,或者尝试过点u所有的边为止.
3. 接下来继续对剩下没有被配对的点一一进行配对,直到所有的点都尝试完毕,找不到新的增广路为止,输出配对数.
#### * 代码示例  
[无权二分图最大匹配--匈牙利算法](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/BipartiteMapMaxMatch)  

### 2. 带权二分图最佳完美匹配---KM算法  
#### * 算法应用  
根据定义,就是在满足条件情况下,能够达到最大完美匹配(边权和最大或者最小)  
1. 广告投资问题:有4个广告却只有3个广告位,如何才能达到收益最大化?  
2. 宝石镶嵌问题:有4个宝石却只有3个镶嵌位,如何镶嵌才能使角色战斗力最高?
3. 战斗伤害问题:角色有3个技能可以使用,有2个怪物,如何出招才能使总伤害最高或者最低?
4. ....
#### * 时间复杂度:
1. 邻接矩阵存储:O(N^3),N为点的总数
2. 邻接表存储:O(M*N^2),M为边数,N为点的总数
#### * 算法特点  
请查看代码注释部分
#### * 代码示例  
[带权二分图最佳完美匹配---KM算法](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/BipartiteMapMaxMatch)  

## 树  
### 1. 神奇的优先队列  
#### 1. 堆排序  
* 解决问题  
1. 排序问题  
2. 找出一组数中第K大(小)的问题
* 时间复杂度  
O(NlogN)
* 代码示例  
[堆排序](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/HeapSort)  

### 2. 并查集  
* 定义:  
  并查集实际上就是并集和查集的过程.集(集合)可以理解为一棵树,即一个根结点连着无数个子节点.并查集也称为不相交集数据结构.形象地来说,有点像"朋友圈":A和B是朋友,A和B就构成了一个朋友圈,C和D是朋友,C和D也构成了一个朋友圈,那么这时,如果B和C在成为了朋友,A、B、C、D就构成了一个大的朋友圈.  
* 算法思想:  
并查集通过一个一维数组来实现,其本质是维护一个森林.刚开始的时候,森林的每个点都是孤立的,也可以理解为每个点就是一棵只有一个结点的树,之后通过一些条件,逐渐将这些树合并成一棵大树.其实合并的过程就
是"认爹"的过程.在"认爹"的过程中,要遵守"靠左"原则和"擒贼先擒王"原则.在每次判断两个结点是否已经在同一棵树中的时候(一棵树其实就是一个集合).也要注意必
须求其根源,中间父亲结点("小BOSS")是不能说明问题的,必须找到其祖宗(树的根结点),判断两个结点的祖宗是否是同一个根结点才行.  
* 遵循原则  
"靠左"原则(求并)    
"擒贼先擒王"(求并)  
补充:  
1. 求并的规则:(1)按大小求并:小的树合并到大的树里面;(2)按高度求并:高度低合并到高度高的树上面  
2. 按大小求并和路径压缩完全兼容,但是按高度求并和路径压缩不完全兼容  
* 编码模式:  
并:Merge-----合并子集  
查:Find -----查找父节点
* 解决问题  
1)判断图中2个点是否已经连通问题(如:图的最小生成树---Kruskal算法中用到)  
2)"朋友圈"问题-------找出一堆数据中有联系的各个组等 
* 代码示例  
[并查集](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/UnionFind)  

## 游戏  
### 视野控制(AOI)-----九宫格  
* [九宫格介绍](https://blog.csdn.net/wangdamingll/article/details/105207975)  
* [示例代码](https://github.com/wangdamingll/Cplusplus-Common-Tools/blob/master/NineBoxView)  

### A* 寻路算法  
* 定义  
是一种启发式的寻路算法  
* A* 算法思想  
1. F = G + H 公式的理解  
2. Dijkstra算法思想  
* [A*算法简介](https://blog.csdn.net/wangdamingll/article/details/105793918)  
* [示例代码](https://github.com/wangdamingll/JobLearn/tree/master/prepare/algorithm/code/AStar)   

---