{"diagram":{"elements":{"note":"","watermark":"","showWatermark":false,"title":"设计模式","version":402,"structure":"mind_free","leftChildren":[{"parent":"root","lineStyle":{"randomLineColor":"#80BC42"},"children":[{"parent":"b7588d868b1e","children":[{"parent":"ad79f0ffe9fa","children":[],"id":"97a2088f6dfc","title":"注意:不是23种标准设计模式之一，但是太常用了，这里就介绍下"},{"parent":"ad79f0ffe9fa","note":"提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类","children":[],"id":"496f6712e4a5","title":"定义"},{"parent":"ad79f0ffe9fa","children":[],"id":"2ab7d1c9d241","title":"本质:简单工厂的本质是选择实现"},{"parent":"ad79f0ffe9fa","children":[{"parent":"a95b793c9123","note":"1.帮助封装\n简单工厂虽然很简单，但是非常友好地帮助我们实现了组件的封装，然后让组件外部能真正面向接口编程。\n2.解耦\n通过简单工厂，实现了客户端和具体实现类的解耦。如同上面的例子，客户端根本就不知道具体是由谁来实现，也不知道具体是如何实现的，客户端只是通过工厂获取它需要的接口对象。","children":[],"id":"992af6ee6007","title":"优点"},{"parent":"a95b793c9123","note":"1.可能增加客户端的复杂度\n如果通过客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这样会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现。\n2.不方便扩展子工厂\n私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单工厂类的子类来改变创建接口的方法的行为了。不过，通常情况下是不需要为简单工厂创建子类的","children":[],"id":"9c69ee6b9b80","title":"缺点"}],"id":"a95b793c9123","title":"优缺点"},{"parent":"ad79f0ffe9fa","children":[{"parent":"c210ed5e84fd","note":"简单工厂是用来选择实现的，可以选择任意接口的实现。一个简单工厂可以有多个用于选择并创建对象的方法，多个方法创建的对象可以有关系也可以没有关系\n\n抽象工厂模式是用来选择产品簇的实现的，也就是说一般抽象工厂里面有多个用于选择并创建对象的方法，但是这些方法所创建的对象之间通常是有关系的，这些被创建的对象通常是构成一个产品簇所需要的部件对象。\n所以从某种意义上来说，简单工厂和抽象工厂是类似的，如果抽象工厂退化成为只有一个实现，不分层次，那么就相当于简单工厂了","children":[],"id":"25c55119e662","title":"简单工厂 &amp;&amp; 抽象工厂"},{"parent":"c210ed5e84fd","note":"工厂方法的本质也是用来选择实现的，跟简单工厂的区别在于工厂方法是把选择具体实现的功能延退到子类去实现。\n如果把工厂方法中选择的实现放到父类直接实现，那就等同于简单工厂。","children":[],"id":"435fb40954c5","title":"简单工厂 &amp;&amp; 工厂方法"}],"id":"c210ed5e84fd","title":"相关模式"},{"parent":"ad79f0ffe9fa","children":[],"id":"0307b472f973","title":"参考网址:https://blog.csdn.net/wangdamingll/article/details/120564417"}],"id":"ad79f0ffe9fa","title":"简单工厂(不属于设计模式)"},{"parent":"b7588d868b1e","children":[{"parent":"8c299a029de4","note":"","children":[],"id":"fbc03dad6aeb","title":"定义:保证一个类仅有一个实例，并提供一个访问它的全局访问点。"},{"parent":"8c299a029de4","children":[],"id":"4c67cfde5399","title":"本质:控制实例的数目"},{"parent":"8c299a029de4","note":"","children":[],"id":"19aa36521a95","title":"适用情况:当需要控制一个类的实例只能有一个，而且客户只能从一个全局访问点访问它时，可以选用单例模式"},{"parent":"8c299a029de4","children":[{"parent":"29494caff8d1","children":[{"parent":"71893fcc07e3","children":[],"id":"9245738c2dee","title":"优点:时间换空间"},{"parent":"71893fcc07e3","children":[],"id":"214b0871be5d","title":"缺点:不是线程安全的,但是采用双重加锁检查的方式实现线程安全"}],"id":"71893fcc07e3","title":"懒汉式"},{"parent":"29494caff8d1","children":[{"parent":"fdeac055806b","children":[],"id":"8827b9eaf0b8","title":"优点:空间换时间 &amp;&amp; 线程安全"},{"parent":"fdeac055806b","children":[],"id":"9bac625b86ac","title":"缺点:占用空间初始化"}],"id":"fdeac055806b","title":"饿汉式"}],"id":"29494caff8d1","title":"优缺点"},{"parent":"8c299a029de4","children":[],"id":"803aa153b060","title":"参考网址:https://blog.csdn.net/wangdamingll/article/details/120555777"}],"id":"8c299a029de4","title":"单例模式"},{"parent":"b7588d868b1e","children":[{"parent":"fc6537448050","note":"定义一个用于创建对象的接口，让子类决定实例化哪一个类， Factory Method使一个类的实例化延迟到其子类","children":[],"id":"68324c1c05e9","title":"定义"},{"parent":"fc6537448050","children":[],"id":"3979e19e9764","title":"本质:延迟到子类来选择实现"},{"parent":"fc6537448050","note":"1.如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延退到子类中去实现。\n2.如果一个类本身就希望由它的子类来创建所需的对象的时候，应该使用工厂方法模式。","children":[],"id":"bcb8f6bbb16b","title":"适用情况"},{"parent":"fc6537448050","children":[{"parent":"7e1902ebe890","note":"1.可以在不知具体实现的情况下编程\n工厂方法模式可以让你在实现功能的时候，如果需要某个产品对象，只需要使用产品的接口即可，而无需关心具体的实现。选择具体实现的任务延退到子类去完成。\n2.更容易扩展对象的新版本\n已有的代码都不会改变，只要新加入一个子类来提供新的工厂方法实现，然后在客户端使用这个新的子类即可。\n3.连接平行的类层次\n工厂方法除了创造产品对象外，在连接平行的类层次上也大显身手。比如有一个硬盘的接口, 具体实现有台式机希捷, 笔记本IBM。所以还会各自有着自己的读写硬盘方法。这种情况下使用工厂方法是比较合适的\n","children":[],"id":"2109fa21cb50","title":"优点"},{"parent":"7e1902ebe890","note":"1.具体产品对象和工厂方法的耦合性。\n在工厂方法模式中，工厂方法是需要创建产品对象的，也就是需要选择具体的产品对象，并创建它们的实例，因此具体产品对象和工厂方法是耦合的。","children":[],"id":"7440cb5bae21","title":"缺点"}],"id":"7e1902ebe890","title":"优缺点"},{"parent":"fc6537448050","children":[{"parent":"1d2e3bf164c2","children":[],"id":"b709489a8fa9","title":"工厂方法 &amp;&amp; 抽象工厂"},{"parent":"1d2e3bf164c2","note":"这两个模式外观类似\n相同点:都有一个抽象类，然后由子类来提供一些实现\n不同点:工厂方法模式的子类专注的是创建产品对象，而模板方法模式的子类专注的是为固定的算法骨架提供某些步骤的实现。\n这两个模式可以组合使用，通常在模板方法模式里面，使用工厂方法来创建模板方法需要的对象。","children":[],"id":"7c4fa2676d8b","title":"工厂方法 &amp;&amp; 模板方法"}],"id":"1d2e3bf164c2","title":"相关模式"}],"id":"fc6537448050","title":"工厂方法"},{"parent":"b7588d868b1e","children":[{"parent":"fba8f6f5c1aa","note":"提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类","children":[],"id":"fe402065dbf6","title":"定义"},{"parent":"fba8f6f5c1aa","children":[],"id":"894e873e7628","title":"本质:选择产品簇的实现"},{"parent":"fba8f6f5c1aa","note":"1.如果希望一个系统独立于它的产品的创建、组合和表示的时候。换句话说，希望一个系统只是知道产品的接口，而不关心实现的时候。\n2.如果一个系统要由多个产品系列中的一个来配置的时候。换句话说，就是可以动态地切换产品簇的时候。\n3.如果要强调一系列相关产品的接口，以便联合使用它们的时候。","children":[],"id":"f061166c1266","title":"适用情况"},{"parent":"fba8f6f5c1aa","children":[{"parent":"956a3b0477a8","note":"1.分离接口和实现\n客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦\n2.使得切换产品簇变得容易\n因为一个具体的工厂实现代表的是一个产品簇，比如上面例子的 Schemel代表装机方案一： Intel的CPU+技嘉的主板，如果要切换成为 Scheme2,那就变成了装机方案二：AMD的CPU+微星的主板。\n客户端选用不同的工厂实现，就相当于是在切换不同的产品簇\n","children":[],"id":"5697353aea50","title":"优点"},{"parent":"956a3b0477a8","note":"1.不太容易扩展新的产品\n前面也提到这个问题了，如果需要给整个产品簇添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。\n2.容易造成类层次复杂\n在使用抽象工厂模式的时候，如果需要选择的层次过多，那么会造成整个类层次变得复杂。\n","children":[],"id":"a669c2d12bad","title":"缺点"}],"id":"956a3b0477a8","title":"优缺点"},{"parent":"fba8f6f5c1aa","children":[{"parent":"ff8c76392145","note":"区别:工厂方法模式一般是针对单独的产品对象的创建，而抽象工厂模式注重产品簇对象的创建。\n联系:如果把抽象工厂创建的产品簇简化，这个产品簇就只有一个产品，那么这个时候的抽象工厂跟工厂方法是差不多的，也就是抽象工厂可以退化成工厂方法，而工厂方法又可以退化成简单工厂\n\\n\n在抽象工厂的实现中，还可以使用工厂方法来提供抽象工厂的具体实现，也就是说它们可以组合使用。\n","children":[],"id":"da0a44f95614","title":"抽象工厂模式 &amp;&amp; 工厂方法模式"},{"parent":"ff8c76392145","note":"在抽象工厂模式里面，具体的工厂实现，在整个应用中，通常一个产品系列只需要一个实例就可以了，因此可以把具体的工厂实现成为单例。","children":[],"id":"c5bf36cc91d5","title":"抽象工厂模式 &amp;&amp;单例模式"}],"id":"ff8c76392145","title":"相关模式"}],"id":"fba8f6f5c1aa","title":"抽象工厂"}],"id":"b7588d868b1e","title":"创建型模式"}],"children":[{"parent":"root","lineStyle":{"randomLineColor":"#FDB813"},"children":[{"parent":"b5f46bed1a87","children":[{"parent":"f940e4fa60ee","note":"定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新","children":[],"id":"f3a703e1dfcb","title":"定义"},{"parent":"f940e4fa60ee","children":[],"id":"68f63f82f93e","title":"本质:触发联动"},{"parent":"f940e4fa60ee","note":"1.当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，那么就可以选用观察者模式，将这两者封装成观察者和目标对象，当目标对象变化的时候，依赖于它的观察者对象也会发生相应的变化。这样就把抽象模型的这两个方面分离开了，使得它们可以独立地改变和复用。\n2.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，这种情况可以选用观察者模式，被更改的那一个对象很明显就相当于是目标对象，而需要连带修改的多个其他对象，就作为多个观察者对象了。\n3.当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的。也就是说这个对象其实不想知道具体被通知的对象。这种情况可以选用观察者模式，这个对象就相当于是目标对象，而被它通知的对象就是观察者对象了\n","children":[],"id":"8d76a31cf719","title":"适用情况"},{"parent":"f940e4fa60ee","children":[{"parent":"0f1e8ea146c7","note":"1.观察者模式实现了观察者和目标之间的抽象耦合\n原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，目标和观察者就只是在抽象层面上耦合了，也就是说目标只是知道观察者接口，并不知道具体的观察者的类，从而实现目标类和具体的观察者类之间解耦。\n2.观察者模式实现了动态联动\n所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态地控制注册的观察者，来控制某个动作的联动范围，从而实现动态联动。\n3.观察者模式支持广播通信\n由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然，也可以通过在目标上添加新的功能来限制广播的范围。\n在广播通信的时候要注意一个问题，就是相互广播造成死循环的问题。比如A和B两个对象互为观察者和目标对象，A对象发生状态变化，然后A来广播信息，B对象接收到通知后，在处理过程中，使得B对象的状态也发生了改变，然后B来广播信息，然后A对象接到通知后，又触发广播信息…,如此A引起B变化，B又引起A变化，从而一直相互广播信息，就造成死循环。\n","children":[],"id":"f7c33bde8566","title":"优点"},{"parent":"0f1e8ea146c7","note":"可能会引起无谓的操作\n由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，那么这次操作就浪费了。其实浪费了还好，最怕引起误更新，那就麻烦了，比如，本应该在执行这次状态更新前把某个观察者删除掉，这样通知的时候就没有这个观察者了，但是现在忘掉了，那么就会引起误操作。\n","children":[],"id":"bb36b9000262","title":"缺点"}],"id":"0f1e8ea146c7","title":"优缺点"},{"parent":"f940e4fa60ee","children":[{"parent":"2f8d7dbeb041","note":"观察者模式和状态模式是有相似之处的。\n观察者模式是当目标状态发生改变时，触发并通知观察者，让观察者去执行相应的操作。而状态模式是根据不同的状态，选择不同的实现，这个实现类的主要功能就是针对状态相应地操作，它不像观察者，观察者本身还有很多其他的功能，接收通知并执行相应处理只是观察者的部分功能。\n当然观察者模式和状态模式是可以结合使用的。观察者模式的重心在触发联动，但是到底决定哪些观察者会被联动，这时就可以采用状态模式来实现了，也可以采用策略模式来进行选择需要联动的观察者。\n","children":[],"id":"f3a8df26f9ad","title":"观察者模式 &amp;&amp; 状态模式"},{"parent":"2f8d7dbeb041","note":"观察者模式和中介者模式是可以结合使用的。前面的例子中目标都只是简单地通知一下，然后让各个观察者自己去完成更新就结束了。如果观察者和被观察的目标之间的交互关系很复杂，比如，有一个界面，里面有三个下拉列表组件，分别是选择国家、省份州、具体的城市，很明显这是一个三级联动，当你选择一个国家的时候，省份/州应该相应改变数据，省份/州一改变，具体的城市也需要改变。这种情况下，很明显需要相关的状态都联动准备好了，然后再一次性地通知观察者。也就是界面做更新处理，不会仅国家改变一下，省份和城市还没有改，就通知界面更新。这种情况就可以使用中介者模式来封装观察者和目标的关系\n","children":[],"id":"6244c2ad7b50","title":"观察者模式 &amp;&amp; 中介者模式"}],"id":"2f8d7dbeb041","title":"相关模式"}],"id":"f940e4fa60ee","title":"观察者模式"},{"parent":"b5f46bed1a87","children":[{"parent":"8fd2f824a3a6","note":"将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。","children":[],"id":"7c67d16cc929","title":"定义"},{"parent":"8fd2f824a3a6","children":[],"id":"504a29e93564","title":"本质:封装请求"},{"parent":"8fd2f824a3a6","note":"1.如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式。将这些需要执行的动作抽象成为命令，然后实现命令的参数化配置。\n2.如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式。将这些请求封装成为命令对象，然后实现将请求队列化。\n3.如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易地实现命令的恢复和重做功能。\n4.如果需要支持当系统扇溃时，能将系统的操作功能重新执行一遍，可以选用命令模式。将这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在系统恢复以后，通过日志获取命令列表，从而重新执行一遍功能。\n5.在需要事务的系统中，可以选用命令模式。命令模式提供了对事务进行建模的方法。命令模式有一个别名就是Transaction。\n","children":[],"id":"543848f1fe12","title":"适用情况"},{"parent":"8fd2f824a3a6","children":[{"parent":"b0c5d495472d","note":"1.更松散的耦合\n命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。\n2.更动态的控制\n命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。\n3.很自然的复合命令\n命令模式中的命令对象能够很容易地组合成复合命令，也就是前面讲的宏命令，从而使系统操作更简单，功能更强大。\n4.更好的扩展性\n由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。\n","children":[],"id":"94d6c1cbacff","title":"优点"}],"id":"b0c5d495472d","title":"优缺点"},{"parent":"8fd2f824a3a6","children":[{"parent":"1332b08da9df","note":"这两个模式可以组合使用。\n在命令模式中，实现宏命令的功能就可以使用组合模式来实现。","children":[],"id":"b84856b3ee03","title":"命令模式 &amp;&amp; 组合模式"},{"parent":"1332b08da9df","note":"这两个模式可以组合使用\n在命令模式中，实现可撤销操作功能时，前面讲了有两种实现方式，其中有一种就是保存命令执行前的状态，撤销的时候就把状态恢复。如果采用这种方式实现，就可以考虑使用备忘录模式\n如果状态存储在命令对象中，那么还可以使用原型模式，把命令对象当作原型来克隆一个新的对象，然后将克隆出来的对象通过备忘录模式存放。\n","children":[],"id":"d917eebbe8be","title":"命令模式 &amp;&amp; 备忘录模式"},{"parent":"1332b08da9df","note":"这两个模式从某种意义上有相似的功能，命令模式可以作为模板方法的一种替代模式，也就是说命令模式可以模仿实现模板方法模式的功能。","children":[],"id":"48561fa94da5","title":"命令模式 &amp;&amp; 模板方法模式"}],"id":"1332b08da9df","title":"相关模式"}],"id":"8fd2f824a3a6","title":"命令模式"},{"parent":"b5f46bed1a87","children":[{"parent":"32953c0db312","note":"表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作","children":[],"id":"39cfa3afeef8","title":"定义"},{"parent":"32953c0db312","children":[],"id":"6cf2b8bc9b8d","title":"本质:预留通路,回调实现"},{"parent":"32953c0db312","note":"1. 如果想对一个对象结构实施一些依赖于对象结构中具体类的操作，可以使用访问者模式。\n\n2. 如果想对一个对象结构中的各个元素进行很多不同的而且不相关的操作，为了避免这些操作使类变得杂乱，可以使用访问者模式。把这些操作分散到不同的访问者对象中去，每个访问者对象实现同一类功能。\n\n3. 如果对象结构很少变动，但是需要经常给对象结构中的元素对象定义新的操作，可以使用访问者模式。","children":[],"id":"cda1b2ab7a46","title":"适用情况"},{"parent":"32953c0db312","children":[{"parent":"c29ec182854a","note":"1. 好的扩展性\n能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n2. 好的复用性\n可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。\n3. 分离无关行为\n可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。","children":[],"id":"53db74b4dbc8","title":"优点"},{"parent":"c29ec182854a","note":"1. 对象结构变化很困难\n不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。\n2. 破坏封装\n访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue,这破坏了对象的封装性。","children":[],"id":"9beab235f053","title":"缺点"}],"id":"c29ec182854a","title":"优缺点"},{"parent":"32953c0db312","children":[{"parent":"2af6513192e6","note":"这两个模式可以组合使用。\n如同前面示例的那样，通过访问者模式给组合对象预留下扩展功能的接口，使得为组合模式的对象结构添加功能非常容易。","children":[],"id":"5557d795c68d","title":"访问者模式 &amp;&amp; 组合模式"},{"parent":"2af6513192e6","note":"这两个模式从表面上看功能有些相似，都能够实现在不修改原对象结构的情况下修改原对象的功能。但是装饰模式更多的是实现对已有功能的加强、修改或者完全全新实现：而访问者模式更多的是实现为对象结构添加新的功能。","children":[],"id":"3655d18b77c8","title":"访问者模式 &amp;&amp; 装饰模式"},{"parent":"2af6513192e6","note":"这两个模式可以组合使用。\n解释器模式在构建抽象语法树的时候，是使用组合模式来构建的，也就是说解释器模式解释并执行的抽象语法树是一个组合对象结构，这个组合对象结构是很少变动的，但是可能经常需要为解释器增加新的功能，实现对同一对象结构的不同解释和执行的功能，这正是访问者模式的优势所在，因此在使用解释器模式的时候通常会组合访问者模式来使用。","children":[],"id":"ac0a69b8e06c","title":"访问者模式 &amp;&amp; 解释器模式"}],"id":"2af6513192e6","title":"相关模式"}],"id":"32953c0db312","title":"访问者模式"},{"parent":"b5f46bed1a87","children":[{"parent":"f194c10a58e7","note":"定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化","children":[],"id":"a2298866fbf8","title":"定义"},{"parent":"f194c10a58e7","children":[{"parent":"0afdba551123","children":[],"id":"7543894944d2","title":"分离算法，选择实现"},{"parent":"0afdba551123","children":[],"id":"bbe6ddf68217","title":"策略算法是相同行为的不同实现"}],"id":"0afdba551123","title":"本质"},{"parent":"f194c10a58e7","note":"1.出现有许多相关的类，仅仅是行为有差别的情况下，可以使用策略模式来使用多个行为中的一个来配置一个类的方法，实现算法动态切换。\n2.出现同一个算法，有很多不同实现的情况下，可以使用策略模式来把这些“不同的实现”实现成为一个算法的类层次。\n3.需要封装算法中，有与算法相关数据的情况下，可以使用策略模式来避免暴露这些跟算法相关的数据结构。\n4.出现抽象一个定义了很多行为的类，并且是通过多个if-lse语句来选择这些行为的情况下，可以使用策略模式来代替这些条件语句。\n","children":[],"id":"d01b9684121d","title":"适用情况"},{"parent":"f194c10a58e7","children":[{"parent":"9ab02efb1900","note":"1.定义一系列算法\n策略模式的功能就是定义一系列算法，实现让这些算法可以相互替换。所以会为这一系列算法定义公共的接口，以约束一系列算法要实现的功能。如果这一系列算法具有公共功能，可以把策略接口实现成为抽象类，把这些公共功能实现到父类中，对于这个问题，前面讲了三种处理方法，这里就不再啰嗦了。\n2.避免多重条件语句\n根据前面的示例会发现，策略模式的一系列策略算法是平等的，是可以互换的，写在一起就是通过if-else结构来组织，如果此时具体的算法实现中又有条件语句，就构成了多重条件语句，使用策略模式能避免这样的多重条件语句。\n3.更好的扩展性\n在策略模式中扩展新的策略实现非常容易，只要增加新的策略实现类，然后在使用策略的地方选择使用这个新的策略实现就可以了。\n","children":[],"id":"e2d67135c937","title":"优点"},{"parent":"9ab02efb1900","note":"1.客户必须了解每种策略的不同\n策略模式也有缺点，比如让客户端来选择具体使用哪一个策略，这就需要客户了解所有的策略，还要了解各种策略的功能和不同，这样才能做出正确的选择，而且这样也暴露了策略的具体实现。\n2.增加了对象数目\n由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。\n3.只适合扁平的算法结构\n策略模式的一系列算法地位是平等的，是可以相互替换的，事实上构成了一个扁平的算法结构，也就是在一个策略接口下，有多个平等的策略算法，就相当于兄弟算法。而且在运行时刻只有一个算法被使用，这就限制了算法使用的层级，使用的时候不能嵌套使用。\n","children":[],"id":"ce018ae30945","title":"缺点"}],"id":"9ab02efb1900","title":"优缺点"},{"parent":"f194c10a58e7","children":[{"parent":"f1f451e065f2","note":"这两个模式从模式结构上看是一样的，但是实现的功能却是不一样的。\n状态模式是根据状态的变化来选择相应的行为，不同的状态对应不同的类，每个状态对应的类实现了该状态对应的功能，在实现功能的同时，还会维护状态数据的变化。这些实现状态对应的功能的类之间是不能相互替换的。策略模式是根据需要或者是客户端的要求来选择相应的实现类，各个实现类是平等的，是可以相互替换的。另外策略模式可以让客户端来选择需要使用的策略算法；而状态模式一般是由上下文，或者是在状态实现类里面来维护具体的状态数据，通常不由客户端来指定状态。\n","children":[],"id":"a78b8f332d27","title":"策略模式 &amp;&amp; 状态模式"},{"parent":"f1f451e065f2","note":"这两个模式可组合使用，如同前面示例的那样。\n模板方法重在封装算法骨架：而策略模式重在分离并封装算法实现","children":[],"id":"6d14c8f13931","title":"策略模式 &amp;&amp; 模板方法模式"},{"parent":"f1f451e065f2","note":"这两个模式可组合使用。\n策略模式分离并封装出一系列的策略算法对象，这些对象的功能通常都比较单一，很多时候就是为了实现某个算法的功能而存在。因此，针对这一系列的、多个细粒度的对象，可以应用享元模式来节省资源，但前提是这些算法对象要被频繁地使用，如果偶尔用一次，就没有必要做成享元了。","children":[],"id":"5e82742794b9","title":"策略模式 &amp;&amp; 享元模式"}],"id":"f1f451e065f2","title":"相关模式"}],"id":"f194c10a58e7","title":"策略模式"},{"parent":"b5f46bed1a87","children":[{"parent":"5b2ef6c86299","note":"允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。","children":[],"id":"aaec9641079d","title":"定义"},{"parent":"5b2ef6c86299","note":"","children":[],"id":"364ffd4fddbd","title":"本质:根据状态来分离和选择行为"},{"parent":"5b2ef6c86299","note":"1.如果一个对象的行为取决于它的状态，而且它必须在运行时刻根据状态来改变它的行为，可以使用状态模式，来把状态和行为分离开。虽然分离开了，但状态和行为是有对应关系的，可以在运行期间，通过改变状态，就能够调用到该状态对应的状态处理对象上去，从而改变对象的行为。\n2.如果一个操作中含有庞大的多分支语句，而且这些分支依赖于该对象的状态，可以使用状态模式，把各个分支的处理分散包装到单独的对象处理类中，这样，这些分支对应的对象就可以不依赖于其他对象而独立变化了。\n","children":[],"id":"8c584eea7b95","title":"适用情况"},{"parent":"5b2ef6c86299","children":[{"parent":"e957df1dfe7c","children":[],"id":"d329548c478d","title":"优点"},{"parent":"e957df1dfe7c","note":"一个状态对应一个状态处理类，会使得程序引入太多的状态类，这样程序变得杂乱。","children":[],"id":"30eece29b47c","title":"缺点"}],"id":"e957df1dfe7c","title":"优缺点"},{"parent":"5b2ef6c86299","children":[{"parent":"7595dd41216d","note":"这两个模式从模式结构上看是一样的，但是实现的功能却是不一样的。\n状态模式是根据状态的变化来选择相应的行为，不同的状态对应不同的类，每个状态对应的类实现了该状态对应的功能，在实现功能的同时，还会维护状态数据的变化。这些实现状态对应的功能的类之间是不能相互替换的。策略模式是根据需要或者是客户端的要求来选择相应的实现类，各个实现类是平等的，是可以相互替换的。另外策略模式可以让客户端来选择需要使用的策略算法；而状态模式一般是由上下文，或者是在状态实现类里面来维护具体的状态数据，通常不由客户端来指定状态。\n","children":[],"id":"2b8944d4e35d","title":"状态模式 &amp;&amp; 策略模式"},{"parent":"7595dd41216d","note":"这两个模式乍一看，功能是很相似的，但是又有区别，可以组合使用。\n这两个模式都是在状态发生改变的时候触发行为，只不过观察者模式的行为是固定的，那就是通知所有的观察者：而状态模式是根据状态来选择不同的处理。\n从表面来看，两个模式功能相似，观察者模式中的被观察对象就好比状态模式中的上下文，观察者模式中当被观察对象的状态发生改变的时候，触发的通知所有观察者的方法就好比是状态模式中，根据状态的变化选择对应的状态处理。\n但实际这两个模式是不同的，观察者模式的目的是在被观察者的状态发生改变的时候，触发观察者联动，具体如何处理观察者模式不管：而状态模式的主要目的在于根据状态来分离和选择行为，当状态发生改变的时候，动态地改变行为。\n这两个模式是可以组合使用的，比如在观察者模式的观察者部分，当被观察对象的状态发生了改变，触发通知了所有的观察者以后，观察者该怎么处理呢？这个时候就可以使用状态模式，根据通知过来的状态选择相应的处理。\n","children":[],"id":"65d26035f512","title":"状态模式 &amp;&amp; 观察者模式"},{"parent":"7595dd41216d","note":"这两个模式可以组合使用，可以把状态模式中的状态处理类实现成单例。","children":[],"id":"c797642c64db","title":"状态模式 &amp;&amp; 单例模式"},{"parent":"7595dd41216d","note":"这两个模式可以组合使用。\n由于状态模式把状态对应的行为分散到多个状态对象中，会造成很多细粒度的状态对象，可以把这些状态处理对象通过享元模式来共享，从而节省资源。","children":[],"id":"44fe71d95ac5","title":"状态模式 &amp;&amp; 享元模式"}],"id":"7595dd41216d","title":"相关模式"}],"id":"5b2ef6c86299","title":"状态模式"}],"id":"b5f46bed1a87","title":"行为型模式"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(51, 156, 168)"},"children":[{"parent":"4c4c70f396ec","children":[{"parent":"ea3fc85bb1f3","note":"为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用","children":[],"id":"d3ef5a391205","title":"定义"},{"parent":"ea3fc85bb1f3","children":[],"id":"3b5ee58d3dbe","title":"本质:封装交互,简化调用"},{"parent":"ea3fc85bb1f3","note":"1.如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。使用外观对象来实现大部分客户需要的功能，从而简化客户的使用。\n2.如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提高子系统的独立性和可移植性。\n3.如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。\n","children":[],"id":"b5389aa9aad6","title":"适用情况"},{"parent":"ea3fc85bb1f3","children":[{"parent":"c85932baf9a7","note":"1.松散耦合\n外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。\n2.简单易用\n外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。\n3.更好地划分访问的层次\n通过合理使用Facade,可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好地隐藏了内部的细节。","children":[],"id":"08fccb83dd87","title":"优点"},{"parent":"c85932baf9a7","note":"过多的或者是不太合理的Facade也容易让人迷惑。到底是调用Facade好呢，还是直接调用模块好。","children":[],"id":"9172e8e36534","title":"缺点"}],"id":"c85932baf9a7","title":"优缺点"},{"parent":"ea3fc85bb1f3","children":[{"parent":"035c404d6c54","note":"这两个模式非常类似，但是却有本质的区别。\n中介者模式主要用来封装多个对象之间相互的交互，多用在系统内部的多个模块之间：而外观模式封装的是单向的交互，是从客户端访问系统的调用，没有从系统中来访问客户端的调用。\n在中介者模式的实现里面，是需要实现具体的交互功能的：而外观模式的实现里面，一般是组合调用或是转调内部实现的功能，通常外观模式本身并不实现这些功能。\n中介者模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现：而外观模式的目的是简化客户端的调用，这点和中介者模式也不同。\n","children":[],"id":"7771ed9423a3","title":"外观模式 &amp;&amp; 中介者模式"},{"parent":"035c404d6c54","note":"通常一个子系统只需要一个外观实例，所以外观模式可以和单例模式组合使用，把Facade类实现成为单例。当然，也可以跟前面示例的那样，把外观类的构造方法私有化，然后把提供给客户端的方法实现成为静态的。","children":[],"id":"da58e773c603","title":"外观模式 &amp;&amp; 单例模式"},{"parent":"035c404d6c54","note":"外观模式的外观类通常需要和系统内部的多个模块交互，每个模块一般都有自己的接口，所以在外观类的具体实现里面，需要获取这些接口，然后组合这些接口来完成客户端的功能。","children":[],"id":"f430eb8041e5","title":"外观模式 &amp;&amp; 抽象工厂模式"}],"id":"035c404d6c54","title":"相关模式"}],"id":"ea3fc85bb1f3","title":"外观模式"},{"parent":"4c4c70f396ec","children":[{"parent":"cb36874ee4dd","note":"动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活","children":[],"id":"d3c8e260391c","title":"定义"},{"parent":"cb36874ee4dd","children":[],"id":"024f0204b462","title":"本质:动态组合"},{"parent":"cb36874ee4dd","note":"1.如果需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这几乎就是装饰模式的主要功能。\n2.如果不适合使用子类来进行扩展的时候，可以考虑使用装饰模式。因为装饰模式是使用的“对象组合”的方式。所谓不适合用子类扩展的方式，比如，扩展功能需要的子类太多，造成子类数目呈爆炸性增长。","children":[],"id":"ea47fb83acb8","title":"适用情况"},{"parent":"cb36874ee4dd","children":[{"parent":"7365935c49f2","note":"1.比继承更灵活\n从为对象添加功能的角度来看，装饰模式比继承更灵活。继承是静态的，而且一旦继承所有子类都有一样的功能。而装饰模式采用把功能分离到每个装饰器当中，然后通过对象组合的方式，在运行时动态地组合功能，每个被装饰的对象最终有哪些功能，是由运行期动态组合的功能来决定的。\n2.更容易复用功能\n装饰模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，使实现装饰器变得简单，更重要的是这样有利于装饰器功能的复用，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，从而实现复用装饰器的功能。\n3.简化高层定义\n装饰模式可以通过组合装饰器的方式，为对象增添任意多的功能。因此在进行高层定义的时候，不用把所有的功能都定义出来，而是定义最基本的就可以了，可以在需要使用的时候，组合相应的装饰器来完成所需的功能。","children":[],"id":"ab15cb685701","title":"优点"},{"parent":"7365935c49f2","note":"1.会产生很多细粒度对象。\n前面说了，装饰模式是把一系列复杂的功能，分散到每个装饰器当中，一般一个装饰器只实现一个功能，这样会产生很多细粒度的对象，而且功能越复杂，需要的细粒度对象越多。","children":[],"id":"d9b25108450b","title":"缺点"}],"id":"7365935c49f2","title":"优缺点"},{"parent":"cb36874ee4dd","children":[{"parent":"6c07c873938e","note":"这是两个没有什么关联的模式，放到一起来说，是因为它们有一个共同的别名：Wrappere\n这两个模式功能上是不一样的，适配器模式是用来改变接口的，而装饰模式是用来改变对象功能的。","children":[],"id":"1495df179de8","title":"装饰模式 &amp;&amp; 适配器模式"},{"parent":"6c07c873938e","note":"这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰看做是只有一个组件的组合。\n但是它们的目的完全不一样，装饰模式是要动态地给对象增加功能：而组合模式是想要管理组合对象和叶子对象，为它们提供一个一致的操作接口给客户端，方便客户端的使用。","children":[],"id":"fbb680cf86de","title":"装饰模式 &amp;&amp; 组合模式"},{"parent":"6c07c873938e","note":"这两个模式可以组合使用。\n策略模式也可以实现动态地改变对象的功能，但是策略模式只是一层选择，也就是根据策略选择一下具体的实现类而已。而装饰模式不是一层，而是递归调用，无数层都可以，只要组合好装饰器的对象组合，那就可以依次调用下去。所以装饰模式更灵活。\n而且策略模式改变的是原始对象的功能，不像装饰模式，后面一个装饰器，改变的是经过前一个装饰器装饰后的对象。也就是策略模式改变的是对象的内核，而装饰模式改变的是对象的外壳。\n这两个模式可以组合使用，可以在一个具体的装饰器中使用策略模式来选择更具体的实现方式。\n","children":[],"id":"d9e8b929a0cb","title":"装饰模式 &amp;&amp; 策略模式"},{"parent":"6c07c873938e","note":"这是两个功能上有相似点的模式。\n模板方法模式主要应用在算法骨架固定的情况，那么要是算法步骤不固定呢，也就是一个相对动态的算法步骤，就可以使用装饰模式了，因为在使用装饰模式的时候，进行装饰器的组装，其实也相当于是一个调用算法步骤的组装，相当于是一个动态的算法骨架。\n既然装饰模式可以实现动态的算法步骤的组装和调用，那么把这些算法步骤固定下来，那就是模板方法模式实现的功能了，因此装饰模式可以模拟实现模板方法模式的功能。\n","children":[],"id":"e72c13836d29","title":"装饰模式 &amp;&amp; 模板方法模式"}],"id":"6c07c873938e","title":"相关模式"}],"id":"cb36874ee4dd","title":"装饰模式"}],"id":"4c4c70f396ec","title":"结构型模式"}],"background":"#FFFFFF","root":true,"theme":"caihong","style":{"background-color":"#1F2766"},"id":"root"}},"meta":{"exportTime":"2023-03-13 16:03:41","member":"","diagramInfo":{"creator":"","created":"2022-08-27 17:57:00","modified":"2023-01-10 16:13:05","title":"设计模式","category":"mind_free"},"id":"6309ea6c5653bb0715e3a5f4","type":"ProcessOn Schema File","version":"1.0"}}